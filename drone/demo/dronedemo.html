<!DOCTYPE html>
<html>
<head>
    <title>quadcopter</title>
    <meta charset="utf-8">
    <style>
    #info{
     position:absolute;
     top:2%;
     width:100%;
     font-size: 20px;
     font-family:"Times New Roman";
     color:white;
     text-align:center;
     }
    #text{
     position:absolute;
     bottom:2%;
     width:100%;
     color: #ffff00;
      font-family:"Times New Roman"
     text-align:center;
     }
  #yreftext {
    width:2%
  }
      body {
        overflow:hidden;
      }
    </style>

</head>
<body>

<div id="info">
 <p>Welcome to the Quacopter World , Enjoy the Show
</p>
<div id="Cameras" style="position:absolute;left:10px;background:white; width:28vw; height:35vh; float:left;">
<canvas id="mycanvas"></canvas>

</div>

 <button id="thrustUp" font-family:"Times New Roman">T-Up</button>
 <button id="thrustDo" font-family:"Times New Roman">T-Down</button>
 <button id="cwTurn" font-family:"Times New Roman">y-Left</button>
 <button id="ccwTurn" font-family:"Times New Roman">y-Right</button>
 <button id="rollRight" font-family:"Times New Roman">r-PORT</button>
 <button id="rollLeft" font-family:"Times New Roman">r-STARBOARD</button>
 <button id="pitchFore" font-family:"Times New Roman">p-FORE</button>
 <button id="pitchAft" font-family:"Times New Roman">p-AFT</button>
  <button id="stop" font-family:"Times New Roman">Space-Stop</button>
 
 <br>
 <input id="yreftext" type="text" value=2><br>
      <!--<input id="yawtext" type="text" value=0>
     <input type=range min=-1 max=1 step="0.05" value = 0 id='yawref'><br>
      <button id="flyup">Take-off</button>-->


    
</div>

<div id="text"></div>




<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/107/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/misc/Gyroscope.js"></script>
<script src="../build/cannon.js"></script>

<script src="../build/LineSegmentsGeometry.js"></script>
<script src="../build/LineGeometry.js"></script>
<script src="../build/LineMaterial.js"></script>
<script src="../build/LineSegments2.js"></script>
<script src="../build/Line2.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="qcommon2.js"></script>
<script src="qangles.js"></script>
<script src="qservos.js"></script>
<script src="https://raw.githack.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>

<script>


class drone{
    constructor(x,y,z){
       this.mesh=builddrone();
       this.cannon=builddroneCannon(x,y,z);
       this.omegas=0;
       this.omegas0=0;
       this.omegas1=0;
       this.omegas2=0;
       this.omegas3=0
       this.omegaGains=1.0;
       this.omegaHovers = Math.sqrt ( this.cannon.mass * world.gravity.length()/4/PROP_KK );
       this.yrefs=y;
       this.turnings=true;
       this.rollings=true;
       this.pitchings=true;
       this.rYaws=0;
       this.rRolls=0;
       this.rPitchs=0;
       this.yawAngles=0;
       this.yawRefs=0;
       this.rollAngles=0;
       this.rollRefs=0;
       this.pitchAngles=0;
       this.pitchRefs=0;
       scene.add(this.mesh);
       world.addBody(this.cannon);
    }
  update(){
   // world.step(dt);
    // Copy coordinates from Cannon.js to Three.js
    this.mesh.position.copy(this.cannon.position);
    this.mesh.quaternion.copy(this.cannon.quaternion); 
    this.yawAngles = getBodyYaw2(this.cannon);
    if((this.yawAngles/Math.PI*180).toFixed(2)==360)this.yawAngles=0;
    this.rollAngles = getBodyRoll2(this.cannon);
    this.pitchAngles = getBodyPitch2(this.cannon);
  }

  Movement(dt){

   if (this.omegaGains === 1.0) 
  this.omegas = hoverServos(this.cannon, dt,this.yrefs);
  else
  this.omegas = this.omegaGains*this.omegaHovers;  // this looks much better

  this.omegas = Math.clamp (this.omegas, 0, 50);
 // console.log("ryaw: "+rYaw+" "+turning);
  
  if (! this.turnings) {
    //console.log("turningryaw: "+rYaw);
    this.rYaws = yawServos (this.cannon, dt,this.yawRefs,this.yawAngles);
    //console.log("servoryaw: "+rYaw);
    this.rYaws = Math.clamp (this.rYaws, -this.omegas, this.omegas);
  }  


// always activate rollServo and pitchServo

  this.rRolls = rollServos (this.cannon, dt,this.rollRefs,this.rollAngles);
  this.rRolls = Math.clamp (this.rRolls, -this.omegas*0.15, this.omegas*0.15);


  this.rPitchs =  pitchServos(this.cannon, dt,this.pitchRefs,this.pitchAngles);
  this.rPitchs = Math.clamp (this.rPitchs, -this.omegas*0.15, this.omegas*0.15);
  

  this.omegas0 = this.omegas - this.rYaws - this.rRolls - this.rPitchs;
  this.omegas1 = this.omegas + this.rYaws - this.rRolls + this.rPitchs;
  this.omegas2 = this.omegas - this.rYaws + this.rRolls + this.rPitchs;
  this.omegas3 = this.omegas + this.rYaws + this.rRolls - this.rPitchs;//0x1742ab

  this.cannon.torque = new CANNON.Vec3(0,0,0);
  this.cannon.angularDamping = 0.39
  this.cannon.linearDamping = 0.39

  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas0*this.omegas0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas1*this.omegas1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas2*this.omegas2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas3*this.omegas3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 

    
  let KT = 0.1;
  // need to add the last argument
  this.cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.omegas0*this.omegas0,0), this.cannon.torque);
  this.cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.omegas1*this.omegas1,0), this.cannon.torque);
  this.cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.omegas2*this.omegas2,0), this.cannon.torque);
  this.cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.omegas3*this.omegas3,0), this.cannon.torque);

  this.mesh.children[25].rotation.z += 2.5*this.omegas0*dt;//motor1
  this.mesh.children[26].rotation.z -= 2.5*this.omegas1*dt;//motor2
  this.mesh.children[27].rotation.z += 2.5*this.omegas2*dt;//motor3
  this.mesh.children[28].rotation.z -= 2.5*this.omegas3*dt;//motor4
  }




  checkkeyborad(){


  const RATIO = 1.0003;
  /////////////////////////////////////////////////////////////
  // for hovering
   if (keyboard.pressed('up')) {
   
    $('#thrustUp').css ("background-color",  'red');
    this.omegaGains *= RATIO;
  }
  if (keyboard.up('up')) {
    this.yrefs = this.cannon.position.y;
    console.log ('set yref: ' + this.yrefs);
    this.omegaGains = 1;
    $('#thrustUp').css ("background-color",  'white');
  }
  if (keyboard.pressed('down')) {
    $('#thrustDo').css ("background-color",  'yellow');
    this.omegaGains /= RATIO;
  }
  if (keyboard.up('down')) {
    this.yrefs = this.cannon.position.y;
    console.log ('set yref: ' + this.yrefs);
    $('#thrustDo').css ("background-color",  'white');
    this.omegaGains = 1;
  }
  /////////////////////////////////////////////////////////////
  // for rolling
  if (keyboard.pressed('D')) {
    $('#rollRight').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.rollRefs = 0.1;
  }
  if (keyboard.up('D')) {
    $('#rollRight').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.rollRefs = 0;
    this.rollings = false;  
  }
  if (keyboard.pressed('A')) {
    $('#rollLeft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.rollRefs = -0.1;
  }
  if (keyboard.up('A')) {
    $('#rollLeft').css ("background-color",  'white');
    this.rollRefs = 0;
    this.rollings = false;    
  }
  /////////////////////////////////////////////////////////////
  // for pitching
  if (keyboard.pressed('W')) {
    $('#pitchFore').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.pitchRefs = 0.1;
    this.pitchings=true;
  }
  if (keyboard.up('W')) {
    $('#pitchFore').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.pitchRefs = 0;
    this.pitchings = false; 
  }
  if (keyboard.pressed('S')) {
    $('#pitchAft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.pitchRefs = -0.1;
        this.pitchings=true;
  }
  if (keyboard.up('S')) {
    $('#pitchAft').css ("background-color",  'white');
    this.pitchRefs= 0;
    this.pitchings = false;   
  }
  /////////////////////////////////////////////////////////////
  // for yawing
  if (keyboard.pressed('left')) {
    $('#cwTurn').css ("background-color",  'yellow');
        this.rYaws = this.omegaHovers*0.1;
        this.turnings = true;
        console.log("drone0.rYaws: "+this.rYaws);
  }
  if (keyboard.up('left')) {
    $('#cwTurn').css ("background-color",  'white');
        this.rYaws = 0;
        this.turnings = false;
    
      // set up stopping reference
      this.yawRefs = getBodyYaw2(this.cannon);
    if((this.yawRefs/Math.PI*180).toFixed(2)==360)this.yawRefs=0;
      console.log ('set thetaRef: ' + (this.yawRefs/Math.PI*180).toFixed(2));
      //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
  }
  if (keyboard.pressed('right')) {
    $('#ccwTurn').css ("background-color",  'yellow');
        this.rYaws = -this.omegaHovers*0.1;
        this.turnings = true;
  }
  if (keyboard.up('right')) {
    $('#ccwTurn').css ("background-color",  'white');
    this.rYaws = 0;
    this.turnings = false;
    // set up stopping reference
    this.yawRefs = getBodyYaw2(this.cannon);
    if((this.yawRefs/Math.PI*180).toFixed(2)==360)this.yawRefs=0;
         //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
      console.log ('set thetaRef: ' + (this.yawRefs/Math.PI*180).toFixed(2));
      //console.log(turning+omegaHover);
  }
  if (keyboard.pressed('space')) {
    this.yawRefs = getBodyYaw2(body);
    this.rYaws=0;
    this.turnings=false;
    this.pitchRefs = 0;
    this.pitchings = false; 
    this.rollRefs = 0;
    this.rolling = false;  
    $('#stop').css ("background-color",  'yellow');
  }
  if (keyboard.up('space')) {
    $('#stop').css ("background-color",  'white');
  }

     }

}

class drone3{
    constructor(x,y,z){
       this.drone3mesh=builddrone();
       this.drone3cannon=builddroneCannon(x,y,z);
       this.drone3omegas=0;
       this.drone3omegas0=0;
       this.drone3omegas1=0;
       this.drone3omegas2=0;
       this.drone3omegas3=0
       this.drone3omegaGains=1.0;
       this.drone3omegaHovers = Math.sqrt ( this.drone3cannon.mass * world.gravity.length()/4/PROP_KK );
       this.drone3yrefs=y;
       this.drone3turnings=true;
       this.drone3rollings=true;
       this.drone3pitchings=true;
       this.drone3rYaws=0;
       this.drone3rRolls=0;
       this.drone3rPitchs=0;
       this.drone3yawAngles=0;
       this.drone3yawRefs=0;
       this.drone3rollAngles=0;
       this.drone3rollRefs=0;
       this.drone3pitchAngles=0;
       this.drone3pitchRefs=0;
       scene.add(this.drone3mesh);
       world.addBody(this.drone3cannon);
    }
  update(){
   // world.step(dt);
    // Copy coordinates from Cannon.js to Three.js
    this.drone3mesh.position.copy(this.drone3cannon.position);
    this.drone3mesh.quaternion.copy(this.drone3cannon.quaternion); 
    this.drone3yawAngles = getBodyYaw2(this.drone3cannon);
    if((this.drone3yawAngles/Math.PI*180).toFixed(2)==360)this.drone3yawAngles=0;
    this.drone3rollAngles = getBodyRoll2(this.drone3cannon);
    this.drone3pitchAngles = getBodyPitch2(this.drone3cannon);
  }

  Movement(dt){

   if (this.drone3omegaGains === 1.0) 
  this.drone3omegas = hoverServos(this.drone3cannon, dt,this.drone3yrefs);
  else
  this.drone3omegas = this.drone3omegaGains*this.drone3omegaHovers;  // this looks much better

  this.drone3omegas = Math.clamp (this.drone3omegas, 0, 50);
 // console.log("ryaw: "+rYaw+" "+turning);
  
  if (! this.drone3turnings) {
    //console.log("turningryaw: "+rYaw);
    this.drone3rYaws = yawServoss (this.drone3cannon, dt,this.drone3yawRefs,this.drone3yawAngles);
    //console.log("servoryaw: "+rYaw);
    this.drone3rYaws = Math.clamp (this.drone3rYaws, -this.drone3omegas, this.drone3omegas);
  }  


// always activate rollServo and pitchServo

  this.drone3rRolls = rollServos (this.drone3cannon, dt,this.drone3rollRefs,this.drone3rollAngles);
  this.drone3rRolls = Math.clamp (this.drone3rRolls, -this.drone3omegas*0.15, this.drone3omegas*0.15);


  this.drone3rPitchs =  pitchServos(this.drone3cannon, dt,this.drone3pitchRefs,this.drone3pitchAngles);
  this.drone3rPitchs = Math.clamp (this.drone3rPitchs, -this.drone3omegas*0.15, this.drone3omegas*0.15);
  

  this.drone3omegas0 = this.drone3omegas - this.drone3rYaws - this.drone3rRolls - this.drone3rPitchs;
  this.drone3omegas1 = this.drone3omegas + this.drone3rYaws - this.drone3rRolls + this.drone3rPitchs;
  this.drone3omegas2 = this.drone3omegas - this.drone3rYaws + this.drone3rRolls + this.drone3rPitchs;
  this.drone3omegas3 = this.drone3omegas + this.drone3rYaws + this.drone3rRolls - this.drone3rPitchs;//0x1742ab

  this.drone3cannon.torque = new CANNON.Vec3(0,0,0);
  this.drone3cannon.angularDamping = 0.39
  this.drone3cannon.linearDamping = 0.39

  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas0*this.drone3omegas0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas1*this.drone3omegas1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas2*this.drone3omegas2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas3*this.drone3omegas3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 

    
  let KT = 0.1;
  // need to add the last argument
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.drone3omegas0*this.drone3omegas0,0), this.drone3cannon.torque);
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.drone3omegas1*this.drone3omegas1,0), this.drone3cannon.torque);
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.drone3omegas2*this.drone3omegas2,0), this.drone3cannon.torque);
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.drone3omegas3*this.drone3omegas3,0), this.drone3cannon.torque);

  this.drone3mesh.children[25].rotation.z += 2.5*this.drone3omegas0*dt;//motor1
  this.drone3mesh.children[26].rotation.z -= 2.5*this.drone3omegas1*dt;//motor2
  this.drone3mesh.children[27].rotation.z += 2.5*this.drone3omegas2*dt;//motor3
  this.drone3mesh.children[28].rotation.z -= 2.5*this.drone3omegas3*dt;//motor4
  }




  checkkeyborad(){


  const RATIO = 1.0003;
  /////////////////////////////////////////////////////////////
  // for hovering
   if (keyboard.pressed('up')) {
   
    $('#thrustUp').css ("background-color",  'red');
    this.drone3omegaGains *= RATIO;
  }
  if (keyboard.up('up')) {
    this.drone3yrefs = this.drone3cannon.position.y;
    console.log ('set yref: ' + this.drone3yrefs);
    this.drone3omegaGains = 1;
    $('#thrustUp').css ("background-color",  'white');
  }
  if (keyboard.pressed('down')) {
    $('#thrustDo').css ("background-color",  'yellow');
    this.drone3omegaGains /= RATIO;
  }
  if (keyboard.up('down')) {
    this.drone3yrefs = this.drone3cannon.position.y;
    console.log ('set yref: ' + this.drone3yrefs);
    $('#thrustDo').css ("background-color",  'white');
    this.drone3omegaGains = 1;
  }
  /////////////////////////////////////////////////////////////
  // for rolling
  if (keyboard.pressed('D')) {
    $('#rollRight').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.drone3rollRefs = 0.1;
  }
  if (keyboard.up('D')) {
    $('#rollRight').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.drone3rollRefs = 0;
    this.drone3rollings = false;  
  }
  if (keyboard.pressed('A')) {
    $('#rollLeft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.drone3rollRefs = -0.1;
  }
  if (keyboard.up('A')) {
    $('#rollLeft').css ("background-color",  'white');
    this.drone3rollRefs = 0;
    this.drone3rollings = false;    
  }
  /////////////////////////////////////////////////////////////
  // for pitching
  if (keyboard.pressed('W')) {
    $('#pitchFore').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.drone3pitchRefs = 0.1;
    this.drone3pitchings=true;
  }
  if (keyboard.up('W')) {
    $('#pitchFore').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.drone3pitchRefs = 0;
    this.drone3pitchings = false; 
  }
  if (keyboard.pressed('S')) {
    $('#pitchAft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.drone3pitchRefs = -0.1;
        this.drone3pitchings=true;
  }
  if (keyboard.up('S')) {
    $('#pitchAft').css ("background-color",  'white');
    this.drone3pitchRefs= 0;
    this.drone3pitchings = false;   
  }
  /////////////////////////////////////////////////////////////
  // for yawing
  if (keyboard.pressed('X')) {

        this.drone3rYaws = this.drone3omegaHovers*0.1;
        this.drone3turnings = true;
        console.log("drone0.rYaws: "+this.drone3rYaws);
  }
  if (keyboard.up('X')) {
        this.drone3rYaws = 0;
        this.drone3turnings = false;
    
      // set up stopping reference
      this.drone3yawRefs = getBodyYaw2(this.drone3cannon);
    if((this.drone3yawRefs/Math.PI*180).toFixed(2)==360)this.drone3yawRefs=0;
      console.log ('set thetaRef: ' + (this.drone3yawRefs/Math.PI*180).toFixed(2));
      //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
  }
  if (keyboard.pressed('Z')) {
        this.drone3rYaws = -this.drone3omegaHovers*0.1;
        this.drone3turnings = true;
  }
  if (keyboard.up('Z')) {
    this.drone3rYaws = 0;
    this.drone3turnings = false;
    // set up stopping reference
    this.drone3yawRefs = getBodyYaw2(this.drone3cannon);
    if((this.drone3yawRefs/Math.PI*180).toFixed(2)==360)this.drone3yawRefs=0;
         //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
      console.log ('set thetaRef: ' + (this.drone3yawRefs/Math.PI*180).toFixed(2));
      //console.log(turning+omegaHover);
  }
  if (keyboard.pressed('space')) {
    this.drone3yawRefs = getBodyYaw2(this.drone3cannon);
    this.drone3rYaws=0;
    this.drone3turnings=false;
    this.drone3pitchRefs = 0;
    this.drone3pitchings = false; 
    this.drone3rollRefs = 0;
    this.drone3rolling = false;  
    $('#stop').css ("background-color",  'yellow');
  }
  if (keyboard.up('space')) {
    $('#stop').css ("background-color",  'white');
  }



     }



}

/*  $('#flyup').click(function() {
       controller=!controller;
    });*/

  
var world, body; 
var camera,upcamera,scene, renderer, clock, keyboard, airplane,circle,light2;
var omega, omega0, omega1, omega2, omega3,omega0Temp,omega1Temp,omega2Temp,omega3Temp;
const SIZE = 1;
var omegaGain = 1.0;
var omegaHover;
const PROP_KK = 0.1;
var controller=false;
// flight maneuver
// hovering
var yref = 5;   
var turning = true;
var rolling = true;
var pitching=true;
var rYaw = 0;
var rRoll = 0;
var rPitch = 0;
var yawAngle = 0, yawRef = 0;
var rollAngle = 0, rollRef = 0;
var pitchAngle = 0, pitchRef = 0;
var gyro;
var autocontroller1=false,autocontroller2=false,ccw=false,sline=false,sloop=false;
var select=2;
var targetPos;
var clock = new THREE.Clock(),curve3,curveObject3,curve4,curveObject4;
var sceneHUD, cameraHUD;
var pointer = [], sprite = [];
var pickables;
var box,line1,line3,line4,fatline1;
var y1,v1,speedRef,y2,v2,numberRef1,y3,v3,numberRef2,y4,v4,numberRef3,y5,v5,numberRef4;////hud 的各种pd控制系统参数
var cylindery1,cylindery2,cylindery3,cylindery4; 
var showdetail=false;
var mouse = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var SpeedCylinder,SpeedChange=2;
var circleAngel=0,SloopAngle=0,curveGeom1,showplane1,showplane2,parking;
var angle1 = angle2 = 0;
var curveCcw,Sloopcurve,point1, curveObjectt, geometryCurve, materialCurve;
var Raidus=3;
var drones=[],drone3s;
/////////////////


init();
animate();
   /* $('#yawref').change ( function() {
        yawref = $(this).val();
        $('#yawtext').val (yawref);
    });
*/

function init() {
    keyboard = new KeyboardState();
    initThree();
    initCannon();


    var ww1 = $('#Cameras').innerWidth();
    var hh1 = $('#Cameras').innerHeight();
    var cc1 = document.getElementById('mycanvas');
    rendererCams = new THREE.WebGLRenderer({
    canvas: cc1
    });
    rendererCams.setSize(ww1, hh1);
    
    light2.target=airplane;

    drones[0]=new drone(3,3,-3);
    drone3s=new drone3(3,3,3);
    //pidR2 = new PIDControllerR2();
  /////////////////////////////
  // omegaHover: stable hover speed
  omegaHover = Math.sqrt ( body.mass * world.gravity.length()/4/PROP_KK );
  cameraHUD = new THREE.OrthographicCamera(-15, 15, 10, -10, -10, 1000);
  cameraHUD.position.z = 100; 
  gyro = new THREE.Gyroscope();
  scene.add (gyro,upcamera)
  gyro.add (camera);
  airplane.add (gyro)
  pickables=[airplane.children[9],airplane.children[11],airplane.children[12],airplane.children[10]];
  targetPos= new THREE.Vector3(5,5,-5);
  var r=1;
    ///////////////////////////
    curve3 = new THREE.CatmullRomCurve3( [
  new THREE.Vector3( 0, 5, 0 ),
  new THREE.Vector3( 3*Math.sqrt(2)-6, 5, 3*Math.sqrt(2) ),
  new THREE.Vector3( -6, 5, 6 ),
  new THREE.Vector3( -3*Math.sqrt(2)-6, 5, 3*Math.sqrt(2) ),
  new THREE.Vector3( -12, 5, 0 ),
  new THREE.Vector3( -3*Math.sqrt(2)-6, 5, -3*Math.sqrt(2) ),
  new THREE.Vector3( -6, 5, -6 ),
  new THREE.Vector3( 3*Math.sqrt(2)-6, 5, -3*Math.sqrt(2) )
  ] ,true);
  var points3 = curve3.getPoints( 50 );
  var geometry3 = new THREE.BufferGeometry().setFromPoints( points3 );
  var material3 = new THREE.LineBasicMaterial( { color : 0xffff00 } );
    curveObject3 = new THREE.Line( geometry3, material3 );
   ////////////////////////////
 
  box=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05, 0.1, 20), new THREE.MeshPhongMaterial());
  speedRef=[];
  sy=[];
  sy[1]=v1=y2=v2=numberRef1=speedRef[1]=sy[2]=sv2=speedRef[2]=sy[3]=sv3=speedRef[3]=sy[4]=sv4=speedRef[4]=y3=v3=numberRef2=y4=v4=numberRef3=y5=v5=numberRef4=0;
  cylindery1=cylinderv1=cylinderRef1=cylindery2=cylinderv2=cylinderRef2=cylindery3=cylinderv3=cylinderRef3=cylindery4=cylinderv=cylinderRef4=0;
  document.addEventListener('mousedown', onDocumentMouseDown, false)
//////////////////////////fatline
var createFatLineGeometry = function (opt) {
 
    opt = opt || {};
    opt.forPoint = opt.forPoint || function (i, per) {
        return {
            x: i * 5,
            y: 0,
            z: 0
        }
    };
    opt.ptCount = opt.ptCount === undefined ? 20 : opt.ptCount;
    opt.colorSolid = opt.colorSolid === undefined ? false : opt.colorSolid;
    opt.color = opt.color === undefined ? new THREE.Color(0xffffff) : opt.color;
 
    // Position and Color Data
    var positions = [],
    colors = [],
    i = 0,
    point,
    geo;
 
    // for each point
    while (i < opt.ptCount) {
 
        // push point
        point = opt.forPoint(i, i / opt.ptCount);
        positions.push(point.x, point.y, point.z);
 
        // push color
        if (!opt.colorSolid) {
            opt.color.setHSL(i / opt.ptCount, 1.0, 0.5);
        }
        colors.push(opt.color.r, opt.color.g, opt.color.b);
 
        i += 1;
    }
 
    // return geo
    geo = new THREE.LineGeometry();
    geo.setPositions(positions);
    geo.setColors(colors);
    return geo;
 
};

fatline1=new THREE.Object3D();
 line1 = createFatLine({
            width: 1,
            geo: createFatLineGeometry({
                ptCount: 80,
                colorSolid: true,
                color: new THREE.Color(0x00ff00),
                forPoint: function (i, per) {
                    return {
                        x: Math.cos(Math.PI*3*(per))*4 ,
                        y: 0,
                        z: Math.sin(Math.PI*3*(per))*4
                    }
                }
            })
        });
 fatline1.add(line1);
 fatline1.position.y=5;
  
    /////////////////////////
        line3 = createFatLine({
            width: 1,
            geo: createFatLineGeometry({
                ptCount: 80,
                colorSolid: true,
                color: new THREE.Color(0xb6d5b9),
                forPoint: function (i, per) {
                    return {
                        x: Math.cos(Math.PI * 4 * (per))*6+6 ,
                        y: 5,
                        z: Math.sin(Math.PI * 4 * (per))*6
                    }
                }
            })
        });
            line4 = createFatLine({
            width: 1,
            geo: createFatLineGeometry({
                ptCount: 80,
                colorSolid: true,
                color: new THREE.Color(0xb6d5b9),
                forPoint: function (i, per) {
                    return {
                        x: Math.cos(Math.PI * 4 * (per))*6+18 ,
                        y: 5,
                        z: Math.sin(Math.PI * 4 * (per))*6
                    }
                }
            })
        });
    createDashboard();
    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    texture = loader.load('https://i.imgur.com/81lKBzW.png');
    parking= new THREE.Mesh( new THREE.CircleGeometry( 1, 32 ), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
    }));
    scene.add(parking);
    parking.rotation.x=-Math.PI/2;
}
function onWindowResize() {
  // renderer resize
  renderer.setSize(window.innerWidth, window.innerHeight);
  whRatio = window.innerWidth / window.innerHeight;
  // perspective camera resize
  camera1.aspect = whRatio;
  camera1.updateProjectionMatrix();
  // orthographic camera resize
  halfH = 20;
  halfW = whRatio * halfH;
  cameraHUD.left = -halfW;
  cameraHUD.right = halfW;
  cameraHUD.top = halfH;
  cameraHUD.bottom = -halfH;
  cameraHUD.updateProjectionMatrix();
  dashBoard[0].position.set(-halfW / 2.5, -(halfH - halfW / 10), 0)
  dashBoard[1].position.set(-halfW / 8, -(halfH - halfW / 10), 0)
  dashBoard[2].position.set(halfW / 8, -(halfH - halfW / 10), 0)
  dashBoard[3].position.set(halfW / 2.5, -(halfH - halfW / 10), 0)
}
function onDocumentMouseDown(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables, false);
  if(intersects.length>0){
     showdetail=!showdetail;
     console.log("2");
}
}
var maxVelocity=0.4;
var orientationcurve=new THREE.Vector3();
var orientationfull=new THREE.Vector3();
var orientation=new THREE.Vector3();
var Time1=0,Time2=0,Time3=0,dtt;
var cylinder=[],ready=false;


function animate() {
   
  rendererCams.render(scene, upcamera);
  upcamera.position.copy(airplane.localToWorld(new THREE.Vector3(0,1,-1.5)));
  upcamera.lookAt(airplane.position);
  var f1 = speedServo(sy[1],v1,speedRef[1]); 
   dtt = 0.005;
  v1 += f1*dtt;
  sy[1] += v1*dtt;
  var f2 = numberServo(y2,v2,numberRef1); 
  v2 += f2*dtt;
  y2 += v2*dtt;
  cylindery1 =y2*0.05;
  var f3 = numberServo(y3,v3,numberRef2); 
  v3 += f3*dtt;
  y3 += v3*dtt;
  cylindery2 =y3*0.05;
  var f4 = numberServo(y4,v4,numberRef3); 
  v4 += f4*dtt;
  y4 += v4*dtt;
  cylindery3 =y4*0.05;
  var f5 = numberServo(y5,v5,numberRef4); 
  v5 += f5*dtt;
  y5 += v5*dtt;
  cylindery4 =y5*0.05;
  var f6= speedServo(sy[2],sv2,speedRef[2]); 
  sv2 += f6*dtt;
  sy[2] += sv2*dtt;
    var f7 = speedServo(sy[3],sv3,speedRef[3]); 
  sv3 += f7*dtt;
  sy[3] += sv3*dtt;
    var f8 = speedServo(sy[4],sv4,speedRef[4]); 
  sv4 += f8*dtt;
  sy[4]+= sv4*dtt;

  let dt = clock.getDelta();

  //orientation=targetPos.clone().sub(body.position);
 
   //  console.log(orientaionLocal);

 /* if(autocontroller1){ 
  autocontroller2=false;
  autocontroller3=false;
     rYaw = 0;
    turning = false;  
  targetPos=new THREE.Vector3(8,5,-10);
     rollRef = 0;
   rolling = false; 
   if(orientation.x-maxVelocity>0){
      rollRef = -0.05;
     }
  if(orientation.x+maxVelocity<0){
    rollRef = 0.05;
  }
    pitchRef =0;
      pitching=false; 
   if(orientation.z-maxVelocity>0){
      pitchRef = 0.05;
        pitching=true;
     }
  if(orientation.z+maxVelocity<0){
      pitchRef = -0.05;
        pitching=true;
  }
}
if(autocontroller2){
  autocontroller1=false;
  autocontroller3=false;
  targetPos=new THREE.Vector3(5,5,-5);
  rYaw = 0;
  turning = false;  
  var localY, localZ;
  localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
  localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
  var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
  var x =new THREE.Vector3(orientation.clone().normalize().x,orientation.clone().normalize().y,orientation.clone().normalize().z);
  var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
  var zW = new THREE.Vector3 (0,0,1);
  var v = zW.projectOnPlane (yL);
  var yawAngle =  rotateAlongAxisTo (x, yL, zL);
     if(yawAngle-0.2>0) {
      rYaw = -omegaHover*0.1;
        turning = true;
     }
  if(yawAngle+0.2<0){
      rYaw = omegaHover*0.1;
        turning = true;
   }
     targetPosx=new THREE.Vector3(0,targetPos.y,targetPos.z);
     orientationx=targetPosx.clone().sub(body.position).normalize();
     var z=zW.projectOnPlane(orientationx);
     pitchRef =0;
     pitching=false;  
   if(z.z>0){
     pitchRef = 0.05;
       pitching=true;
     }
  if(z.z<0){
     pitchRef = -0.05;
       pitching=true;
  }
}*/
////////////圆平面的变化
if(ccw){
  showplane2.visible=false;
  CreateCurve(circleAngel);
  scene.add(box,fatline1);
  fatline1.rotation.z=circleAngel;
  showplane1.rotation.z=circleAngel;
  showplane1.visible=true;
  scene.remove(curveObject3,curveObject4);
  autocontroller2=false;
  autocontroller1=false;
  box.position.copy(curveCcw.getPointAt(Time1 % 1));
  box.position.y+=0.05
    //console.log(Time1);
  targetPos=curveCcw.getPointAt(Time1 % 1);
  orientationcurve=targetPos.clone().sub(body.position).normalize();
 // orientationcurve=curveCcw.getTangent(Time1 % 1);
  yref=targetPos.y;
  rYaw = 0;
  turning = false;  
  var localY, localZ;
  localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
  localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
  var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
  var x =new THREE.Vector3(orientationcurve.clone().normalize().x,orientationcurve.clone().normalize().y,orientationcurve.clone().normalize().z);
  var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
  var zW = new THREE.Vector3 (0,0,1);
  var v = zW.projectOnPlane (yL);
  var yawAngle =  rotateAlongAxisTo (x, yL, zL);
  if(yawAngle-0.2>0) {
  rYaw = -omegaHover*0.1;
  turning = true;
  }
  if(yawAngle+0.2<0){
  rYaw = omegaHover*0.1;
  turning = true;
  }
  targetPosx=new THREE.Vector3(0,targetPos.y,targetPos.z);
  orientationx=targetPosx.clone().sub(body.position).normalize();
  var z=zW.projectOnPlane(orientationx);
  pitchRef =0;
  pitching=false;  
  if(z.z>0){
  pitchRef = 0.02;
  pitching=true;
  }
  if(z.z<0){
  pitchRef = -0.02;
  pitching=true;
  }
  if(targetPos.x-body.position.x<=0.5&&targetPos.x-body.position.x>=-0.5){ 
      if(targetPos.z-body.position.z<=0.5&&targetPos.z-body.position.z>=-0.5){
      Time1 += 0.00095;
      turning=false;
      pitchRef = 0;
      pitching = false; 
      rollRef = 0;
      rolling = false;
      ready=true;
    }
 }  
}


  // not in thrust+/- mode, activate hoverServo
  if (omegaGain === 1.0) 
  omega = hoverServo(body, dt);
  else
  omega = omegaGain*omegaHover;  // this looks much better
  omega = Math.clamp (omega, 0, 50);
 // console.log("ryaw: "+rYaw+" "+turning);
  
  if (! turning) {
    //console.log("turningryaw: "+rYaw);
    rYaw = yawServo (body, dt);
    //console.log("servoryaw: "+rYaw);
    rYaw = Math.clamp (rYaw, -omega, omega);
  }  
// always activate rollServo and pitchServo
  rRoll = rollServo (body, dt);
  rRoll = Math.clamp (rRoll, -omega*0.15, omega*0.15);
  rPitch = pitchServo (body, dt);
  rPitch = Math.clamp (rPitch, -omega*0.15, omega*0.15);
  
  omega0Temp=omega0;
  omega1Temp=omega1;
  omega2Temp=omega2;
  omega3Temp=omega3;
  omega0 = omega - rYaw - rRoll - rPitch;
  omega1 = omega + rYaw - rRoll + rPitch;
  omega2 = omega - rYaw + rRoll + rPitch;
  omega3 = omega + rYaw + rRoll - rPitch;//0x1742ab
  if(showdetail){
 
  cylinderRef1=omega0*8;
  cylinderRef2=omega1*8;
  cylinderRef3=omega2*8;
  cylinderRef4=omega3*8;
  airplane.children[13].children[0].visible=true;
  airplane.children[14].children[0].visible=true;
  airplane.children[15].children[0].visible=true;
  airplane.children[16].children[0].visible=true;
  airplane.children[25].children[0].visible=true;
  airplane.children[26].children[0].visible=true;
  airplane.children[27].children[0].visible=true;
  airplane.children[28].children[0].visible=true;
 
  airplane.children[25].children[0].scale.y = -3*cylindery1;
  airplane.children[26].children[0].scale.y = 3*cylindery2;
  airplane.children[27].children[0].scale.y = -3*cylindery3;
  airplane.children[28].children[0].scale.y = 3*cylindery4;
/* airplane.children[13].add(new THREE.AxesHelper (0.5));
 airplane.children[14].add(new THREE.AxesHelper (0.5));
airplane.children[15].add(new THREE.AxesHelper (0.5));
airplane.children[16].add(new THREE.AxesHelper (0.5));*/
}
 else {
  airplane.children[13].children[0].visible=false;
  airplane.children[14].children[0].visible=false;
  airplane.children[15].children[0].visible=false;
  airplane.children[16].children[0].visible=false;
  airplane.children[25].children[0].visible=false;
  airplane.children[26].children[0].visible=false;
  airplane.children[27].children[0].visible=false;
  airplane.children[28].children[0].visible=false;
 /*  airplane.children[13].remove(new THREE.AxesHelper (0.5));
 airplane.children[14].remove(new THREE.AxesHelper (0.5));
airplane.children[15].remove(new THREE.AxesHelper (0.5));
airplane.children[16].remove(new THREE.AxesHelper (0.5));*/
 }
  /*omega0 = omega  - rRoll - rPitch;
  omega1 = omega  - rRoll + rPitch;
  omega2 = omega  + rRoll + rPitch;
  omega3 = omega  + rRoll - rPitch;*/
  /*omega0 = omega - rYaw;
  omega1 = omega + rYaw;
  omega2 = omega - rYaw;
  omega3 = omega + rYaw;*/
  body.torque = new CANNON.Vec3(0,0,0);
  body.angularDamping = 0.39
  body.linearDamping = 0.39
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega0*omega0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega1*omega1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega2*omega2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega3*omega3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 
    
  let KT = 0.1;
  // need to add the last argument
  body.torque.vadd (new CANNON.Vec3(0, -KT*omega0*omega0,0), body.torque);
  body.torque.vadd (new CANNON.Vec3(0,  KT*omega1*omega1,0), body.torque);
  body.torque.vadd (new CANNON.Vec3(0, -KT*omega2*omega2,0), body.torque);
  body.torque.vadd (new CANNON.Vec3(0,  KT*omega3*omega3,0), body.torque);
  //bug ... for pitching, weird number from KT not zero
  //console.log (body.torque)         
  //console.log("omega0:"+omega0.toFixed(2)+" omega1:"+omega1.toFixed(2)+" omega2:"+omega2.toFixed(2)+" omega3:"+omega3.toFixed(2));
  //requestAnimationFrame( animate );
  //renderer.render( scene, camera );
    var angle = [], t = 10;
    for(i=0;i<4;i++){
    angle[i] = 0
    }
    angle[0] = 4.9 / 14 * omega0;
    numberRef1=-omega0.toFixed(1);
    sprite[0].text = y2.toFixed(2);
    angle[1] = 4.9 / 14 * omega1;
    numberRef2=omega1.toFixed(1);
    sprite[1].text =y3.toFixed(2);
    numberRef3=-omega2.toFixed(1);
    angle[2] = 4.9 / 14 * omega2;
    sprite[2].text = y4.toFixed(2);
    numberRef4=omega3.toFixed(1);;
    angle[3] = 4.9 / 14 * omega3;
    sprite[3].text = y5.toFixed(2);
    for (i = 0; i < 4; i++) {
    angle[i] = Math.clamp(angle[i], 0, 4.9);
    speedRef[i+1]= -angle[i] + 0.86
    pointer[i].rotation.z = sy[i+1];
    }
    render();
    drones[0].Movement(dt);
    drone3s.Movement(dt);
    handleKeys();

    keyboard.update();
    updatePhysics();
    drones[0].update();
    drone3s.update();
  // render propeller in airplane
// console.log(airplane.children[25].children[0].mesh.parameters)
  airplane.children[25].rotation.z += 2.5*omega0*dt;//motor1
  airplane.children[26].rotation.z -= 2.5*omega1*dt;//motor2
  airplane.children[27].rotation.z += 2.5*omega2*dt;//motor3
  airplane.children[28].rotation.z -= 2.5*omega3*dt;//motor4

}
function render(){
  renderer.clear(true);
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
  renderer.render(sceneHUD, cameraHUD);
}
function handleKeys () {
  keyboard.update();
  drones[0].checkkeyborad();
  const RATIO = 1.0003;
  /////////////////////////////////////////////////////////////
  // for hovering
  if (keyboard.pressed('up')) {
    controller=true;
    $('#thrustUp').css ("background-color",  'red');
    omegaGain *= RATIO;
  }
  if (keyboard.up('up')) {
    yref = body.position.y;
    console.log ('set yref: ' + yref);
    omegaGain = 1;
    $('#thrustUp').css ("background-color",  'white');
  }
  if (keyboard.pressed('down')) {
    $('#thrustDo').css ("background-color",  'yellow');
    omegaGain /= RATIO;
  }
  if (keyboard.up('down')) {
    yref = body.position.y;
    console.log ('set yref: ' + yref);
    $('#thrustDo').css ("background-color",  'white');
    omegaGain = 1;
  }
  /////////////////////////////////////////////////////////////
  // for rolling
  if (keyboard.pressed('D')) {
    $('#rollRight').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    rollRef = 0.1;
  }
  if (keyboard.up('D')) {
    $('#rollRight').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    rollRef = 0;
    rolling = false;  
  }
  if (keyboard.pressed('A')) {
    $('#rollLeft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        rollRef = -0.1;
  }
  if (keyboard.up('A')) {
    $('#rollLeft').css ("background-color",  'white');
    rollRef = 0;
    rolling = false;    
  }
  /////////////////////////////////////////////////////////////
  // for pitching
  if (keyboard.pressed('W')) {
    $('#pitchFore').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    pitchRef = 0.1;
    pitching=true;
  }
  if (keyboard.up('W')) {
    $('#pitchFore').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    pitchRef = 0;
    pitching = false; 
  }
  if (keyboard.pressed('S')) {
    $('#pitchAft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        pitchRef = -0.1;
        pitching=true;
  }
  if (keyboard.up('S')) {
    $('#pitchAft').css ("background-color",  'white');
    pitchRef = 0;
    pitching = false;   
  }
  /////////////////////////////////////////////////////////////
  // for yawing
  if (keyboard.pressed('left')) {
    $('#cwTurn').css ("background-color",  'yellow');
        rYaw = omegaHover*0.1;
        turning = true;
  }
  if (keyboard.up('left')) {
    $('#cwTurn').css ("background-color",  'white');
        rYaw = 0;
        turning = false;
    
      // set up stopping reference
      yawRef = getBodyYaw2(body);
    if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
      console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
      //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
  }
  if (keyboard.pressed('right')) {
    $('#ccwTurn').css ("background-color",  'yellow');
        rYaw = -omegaHover*0.1;
        turning = true;
  }
  if (keyboard.up('right')) {
    $('#ccwTurn').css ("background-color",  'white');
    rYaw = 0;
    turning = false;
    // set up stopping reference
    yawRef = getBodyYaw2(body);
    if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
         //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
      console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
      console.log(turning+omegaHover);
  }
  if (keyboard.pressed('space')) {
    yawRef = getBodyYaw2(body);
    rYaw=0;
    turning=false;
    pitchRef = 0;
    pitching = false; 
    rollRef = 0;
    rolling = false;  
    $('#stop').css ("background-color",  'yellow');
  }
  if (keyboard.up('space')) {
    $('#stop').css ("background-color",  'white');
  }
    $('#gain').val (omegaGain);
    $('#yreftext').val (yref.toFixed(2));
  drone3s.checkkeyborad();
  


}
function updatePhysics() {
  var timeStep=1/50;
  world.step(timeStep);
  // Copy coordinates from Cannon.js to Three.js
  airplane.position.copy(body.position);
  airplane.quaternion.copy(body.quaternion); 
  yawAngle = getBodyYaw2(body);
 if((yawAngle/Math.PI*180).toFixed(2)==360)yawAngle=0;
  rollAngle = getBodyRoll2(body);
  pitchAngle = getBodyPitch2(body);
  
 /* $('#text').html (`${omegaGain.toFixed(3)}:[ ${body.position.x.toFixed(3)}, ${body.position.y.toFixed(2)}, 
    ${body.position.z.toFixed(3)} ] <br>      
  [${yawRef.toFixed(3)}] : [Y: ${yawAngle.toFixed(3)} ] [R: ${rollAngle.toFixed(3)} ] [P: ${pitchAngle.toFixed(3)} ]  
  <br>
     [omega0:${omega0.toFixed(3)}] : [omega1: ${omega1.toFixed(3)} ] [omega2: ${omega2.toFixed(3)} ] [omega3: ${omega3.toFixed(3)} ]         `);  */
}
</script>
</body>
</html>