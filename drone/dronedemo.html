<!DOCTYPE html>
<html>
<head>
    <title>quadcopter</title>
    <meta charset="utf-8">
    <style>
    #info{
     position:absolute;
     top:2%;
     width:100%;
     font-size: 20px;
     font-family:"Times New Roman";
     color:white;
     text-align:center;
     }
    #text{
     position:absolute;
     bottom:2%;
     width:100%;
     color: #ffff00;
      font-family:"Times New Roman"
     text-align:center;
     }
  #yreftext {
    width:2%
  }
      body {
        overflow:hidden;
      }
    </style>

</head>
<body>

<div id="info">
 <p>Welcome to the Quacopter World , Enjoy the Show
</p>
<div id="Cameras" style="position:absolute;left:10px;background:white; width:20vw; height:23.5vh; float:left;">
<canvas id="mycanvas"></canvas>

</div>


 <button id="thrustUp" font-family:"Times New Roman">T-Up</button>
 <button id="thrustDo" font-family:"Times New Roman">T-Down</button>
 <button id="cwTurn" font-family:"Times New Roman">y-Left</button>
 <button id="ccwTurn" font-family:"Times New Roman">y-Right</button>
 <button id="rollRight" font-family:"Times New Roman">r-PORT</button>
 <button id="rollLeft" font-family:"Times New Roman">r-STARBOARD</button>
 <button id="pitchFore" font-family:"Times New Roman">p-FORE</button>
 <button id="pitchAft" font-family:"Times New Roman">p-AFT</button>
  <button id="stop" font-family:"Times New Roman">Space-Stop</button>
 
 <br>
 <input id="yreftext" type="text" value=2><br>
      <!--<input id="yawtext" type="text" value=0>
     <input type=range min=-1 max=1 step="0.05" value = 0 id='yawref'><br>
      <button id="flyup">Take-off</button>-->
   <button id="showStart1">Show1</button>
  <button id="showStart2">Show2</button>
    <button id="adddrone">Add</button><br>
           <button id="showline1">ShowGuideline1</button>
  <button id="showline2">ShowGuideline2</button>
</div>

<div id="text"></div>




<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/107/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/misc/Gyroscope.js"></script>
<script src="../build/cannon.js"></script>

<script src="../build/LineSegmentsGeometry.js"></script>
<script src="../build/LineGeometry.js"></script>
<script src="../build/LineMaterial.js"></script>
<script src="../build/LineSegments2.js"></script>
<script src="../build/Line2.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="qcommon2.js"></script>
<script src="qangles.js"></script>
<script src="qservos.js"></script>
<script src="https://raw.githack.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>

<script>

class drone{
    constructor(x,y,z){
       this.mesh=builddrone();
       this.cannon=builddroneCannon(x,y,z);
       this.omegas=0;
       this.omegas0=0;
       this.omegas1=0;
       this.omegas2=0;
       this.omegas3=0
       this.omegaGains=1.0;
       this.omegaHovers = Math.sqrt ( this.cannon.mass * world.gravity.length()/4/PROP_KK );
       this.yrefs=y;
       this.turnings=true;
       this.rollings=true;
       this.pitchings=true;
       this.rYaws=0;
       this.rRolls=0;
       this.rPitchs=0;
       this.yawAngles=0;
       this.yawRefs=0;
       this.rollAngles=0;
       this.rollRefs=0;
       this.pitchAngles=0;
       this.pitchRefs=0;
       scene.add(this.mesh);
       world.addBody(this.cannon);
    }
  update(){
   // world.step(dt);
    // Copy coordinates from Cannon.js to Three.js
    this.mesh.position.copy(this.cannon.position);
    this.mesh.quaternion.copy(this.cannon.quaternion); 
    this.yawAngles = getBodyYaw2(this.cannon);
    if((this.yawAngles/Math.PI*180).toFixed(2)==360)this.yawAngles=0;
    this.rollAngles = getBodyRoll2(this.cannon);
    this.pitchAngles = getBodyPitch2(this.cannon);
  }

  Movement(dt){

   if (this.omegaGains === 1.0) 
  this.omegas = hoverServos(this.cannon, dt,this.yrefs);
  else
  this.omegas = this.omegaGains*this.omegaHovers;  // this looks much better

  this.omegas = Math.clamp (this.omegas, 0, 50);
 // console.log("ryaw: "+rYaw+" "+turning);
  
  if (! this.turnings) {
    //console.log("turningryaw: "+rYaw);
    this.rYaws = yawServo2 (this.cannon, dt,this.yawRefs,this.yawAngles);
    //console.log("servoryaw: "+rYaw);
    this.rYaws = Math.clamp (this.rYaws, -this.omegas, this.omegas);
  }  


// always activate rollServo and pitchServo

  this.rRolls = rollServos (this.cannon, dt,this.rollRefs,this.rollAngles);
  this.rRolls = Math.clamp (this.rRolls, -this.omegas*0.15, this.omegas*0.15);


  this.rPitchs =  pitchServos(this.cannon, dt,this.pitchRefs,this.pitchAngles);
  this.rPitchs = Math.clamp (this.rPitchs, -this.omegas*0.15, this.omegas*0.15);
  

  this.omegas0 = this.omegas - this.rYaws - this.rRolls - this.rPitchs;
  this.omegas1 = this.omegas + this.rYaws - this.rRolls + this.rPitchs;
  this.omegas2 = this.omegas - this.rYaws + this.rRolls + this.rPitchs;
  this.omegas3 = this.omegas + this.rYaws + this.rRolls - this.rPitchs;//0x1742ab

  this.cannon.torque = new CANNON.Vec3(0,0,0);
  this.cannon.angularDamping = 0.39
  this.cannon.linearDamping = 0.39

  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas0*this.omegas0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas1*this.omegas1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas2*this.omegas2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
  this.cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.omegas3*this.omegas3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 

    
  let KT = 0.1;
  // need to add the last argument
  this.cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.omegas0*this.omegas0,0), this.cannon.torque);
  this.cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.omegas1*this.omegas1,0), this.cannon.torque);
  this.cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.omegas2*this.omegas2,0), this.cannon.torque);
  this.cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.omegas3*this.omegas3,0), this.cannon.torque);

  this.mesh.children[25].rotation.z += 2.5*this.omegas0*dt;//motor1
  this.mesh.children[26].rotation.z -= -2.5*this.omegas1*dt;//motor2
  this.mesh.children[27].rotation.z += -2.5*this.omegas2*dt;//motor3
  this.mesh.children[28].rotation.z -= 2.5*this.omegas3*dt;//motor4
  }




  checkkeyborad(){


  const RATIO = 1.0003;
  /////////////////////////////////////////////////////////////
  // for hovering
   if (keyboard.pressed('up')) {
   
    $('#thrustUp').css ("background-color",  'red');
    this.omegaGains *= RATIO;
  }
  if (keyboard.up('up')) {
    this.yrefs = this.cannon.position.y;
    console.log ('set yref: ' + this.yrefs);
    this.omegaGains = 1;
    $('#thrustUp').css ("background-color",  'white');
  }
  if (keyboard.pressed('down')) {
    $('#thrustDo').css ("background-color",  'yellow');
    this.omegaGains /= RATIO;
  }
  if (keyboard.up('down')) {
    this.yrefs = this.cannon.position.y;
    console.log ('set yref: ' + this.yrefs);
    $('#thrustDo').css ("background-color",  'white');
    this.omegaGains = 1;
  }
  /////////////////////////////////////////////////////////////
  // for rolling
  if (keyboard.pressed('D')) {
    $('#rollRight').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.rollRefs = 0.1;
  }
  if (keyboard.up('D')) {
    $('#rollRight').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.rollRefs = 0;
    this.rollings = false;  
  }
  if (keyboard.pressed('A')) {
    $('#rollLeft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.rollRefs = -0.1;
  }
  if (keyboard.up('A')) {
    $('#rollLeft').css ("background-color",  'white');
    this.rollRefs = 0;
    this.rollings = false;    
  }
  /////////////////////////////////////////////////////////////
  // for pitching
  if (keyboard.pressed('W')) {
    $('#pitchFore').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.pitchRefs = 0.1;
    this.pitchings=true;
  }
  if (keyboard.up('W')) {
    $('#pitchFore').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.pitchRefs = 0;
    this.pitchings = false; 
  }
  if (keyboard.pressed('S')) {
    $('#pitchAft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.pitchRefs = -0.1;
        this.pitchings=true;
  }
  if (keyboard.up('S')) {
    $('#pitchAft').css ("background-color",  'white');
    this.pitchRefs= 0;
    this.pitchings = false;   
  }
  /////////////////////////////////////////////////////////////
  // for yawing
  if (keyboard.pressed('left')) {
    $('#cwTurn').css ("background-color",  'yellow');
        this.rYaws = this.omegaHovers*0.1;
        this.turnings = true;
        console.log("drone0.rYaws: "+this.rYaws);
  }
  if (keyboard.up('left')) {
    $('#cwTurn').css ("background-color",  'white');
        this.rYaws = 0;
        this.turnings = false;
    
      // set up stopping reference
      this.yawRefs = getBodyYaw2(this.cannon);
    if((this.yawRefs/Math.PI*180).toFixed(2)==360)this.yawRefs=0;
      console.log ('set thetaRef: ' + (this.yawRefs/Math.PI*180).toFixed(2));
      //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
  }
  if (keyboard.pressed('right')) {
    $('#ccwTurn').css ("background-color",  'yellow');
        this.rYaws = -this.omegaHovers*0.1;
        this.turnings = true;
  }
  if (keyboard.up('right')) {
    $('#ccwTurn').css ("background-color",  'white');
    this.rYaws = 0;
    this.turnings = false;
    // set up stopping reference
    this.yawRefs = getBodyYaw2(this.cannon);
    if((this.yawRefs/Math.PI*180).toFixed(2)==360)this.yawRefs=0;
         //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
      console.log ('set thetaRef: ' + (this.yawRefs/Math.PI*180).toFixed(2));
      //console.log(turning+omegaHover);
  }
  if (keyboard.pressed('space')) {
    this.yawRefs = getBodyYaw2(body);
    this.rYaws=0;
    this.turnings=false;
    this.pitchRefs = 0;
    this.pitchings = false; 
    this.rollRefs = 0;
    this.rolling = false;  
    $('#stop').css ("background-color",  'yellow');
  }
  if (keyboard.up('space')) {
    $('#stop').css ("background-color",  'white');
  }

     }

}

class drone3{
    constructor(x,y,z){
       this.drone3mesh=builddrone();
       this.drone3cannon=builddroneCannon(x,y,z);
       this.drone3omegas=0;
       this.drone3omegas0=0;
       this.drone3omegas1=0;
       this.drone3omegas2=0;
       this.drone3omegas3=0
       this.drone3omegaGains=1.0;
       this.drone3omegaHovers = Math.sqrt ( this.drone3cannon.mass * world.gravity.length()/4/PROP_KK );
       this.drone3yrefs=y;
       this.drone3turnings=true;
       this.drone3rollings=true;
       this.drone3pitchings=true;
       this.drone3rYaws=0;
       this.drone3rRolls=0;
       this.drone3rPitchs=0;
       this.drone3yawAngles=0;
       this.drone3yawRefs=0;
       this.drone3rollAngles=0;
       this.drone3rollRefs=0;
       this.drone3pitchAngles=0;
       this.drone3pitchRefs=0;
       scene.add(this.drone3mesh);
       world.addBody(this.drone3cannon);
    }
  update(){
   // world.step(dt);
    // Copy coordinates from Cannon.js to Three.js
    this.drone3mesh.position.copy(this.drone3cannon.position);
    this.drone3mesh.quaternion.copy(this.drone3cannon.quaternion); 
    this.drone3yawAngles = getBodyYaw2(this.drone3cannon);
    if((this.drone3yawAngles/Math.PI*180).toFixed(2)==360)this.drone3yawAngles=0;
    this.drone3rollAngles = getBodyRoll2(this.drone3cannon);
    this.drone3pitchAngles = getBodyPitch2(this.drone3cannon);
  }

  Movement(dt){

   if (this.drone3omegaGains === 1.0) 
  this.drone3omegas = hoverServos(this.drone3cannon, dt,this.drone3yrefs);
  else
  this.drone3omegas = this.drone3omegaGains*this.drone3omegaHovers;  // this looks much better

  this.drone3omegas = Math.clamp (this.drone3omegas, 0, 50);
 // console.log("ryaw: "+rYaw+" "+turning);
  
  if (! this.drone3turnings) {
    //console.log("turningryaw: "+rYaw);
    this.drone3rYaws = yawServo3 (this.drone3cannon, dt,this.drone3yawRefs,this.drone3yawAngles);
    //console.log("servoryaw: "+rYaw);
    this.drone3rYaws = Math.clamp (this.drone3rYaws, -this.drone3omegas, this.drone3omegas);
  }  


// always activate rollServo and pitchServo

  this.drone3rRolls = rollServos (this.drone3cannon, dt,this.drone3rollRefs,this.drone3rollAngles);
  this.drone3rRolls = Math.clamp (this.drone3rRolls, -this.drone3omegas*0.15, this.drone3omegas*0.15);


  this.drone3rPitchs =  pitchServos(this.drone3cannon, dt,this.drone3pitchRefs,this.drone3pitchAngles);
  this.drone3rPitchs = Math.clamp (this.drone3rPitchs, -this.drone3omegas*0.15, this.drone3omegas*0.15);
  

  this.drone3omegas0 = this.drone3omegas - this.drone3rYaws - this.drone3rRolls - this.drone3rPitchs;
  this.drone3omegas1 = this.drone3omegas + this.drone3rYaws - this.drone3rRolls + this.drone3rPitchs;
  this.drone3omegas2 = this.drone3omegas - this.drone3rYaws + this.drone3rRolls + this.drone3rPitchs;
  this.drone3omegas3 = this.drone3omegas + this.drone3rYaws + this.drone3rRolls - this.drone3rPitchs;//0x1742ab

  this.drone3cannon.torque = new CANNON.Vec3(0,0,0);
  this.drone3cannon.angularDamping = 0.39
  this.drone3cannon.linearDamping = 0.39

  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas0*this.drone3omegas0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas1*this.drone3omegas1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas2*this.drone3omegas2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
  this.drone3cannon.applyLocalForce (new CANNON.Vec3(0,PROP_KK*this.drone3omegas3*this.drone3omegas3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 

    
  let KT = 0.1;
  // need to add the last argument
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.drone3omegas0*this.drone3omegas0,0), this.drone3cannon.torque);
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.drone3omegas1*this.drone3omegas1,0), this.drone3cannon.torque);
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0, -KT*this.drone3omegas2*this.drone3omegas2,0), this.drone3cannon.torque);
  this.drone3cannon.torque.vadd (new CANNON.Vec3(0,  KT*this.drone3omegas3*this.drone3omegas3,0), this.drone3cannon.torque);

  this.drone3mesh.children[25].rotation.z += 2.5*this.drone3omegas0*dt;//motor1
  this.drone3mesh.children[26].rotation.z -= -2.5*this.drone3omegas1*dt;//motor2
  this.drone3mesh.children[27].rotation.z += 2.5*this.drone3omegas2*dt;//motor3
  this.drone3mesh.children[28].rotation.z -= -2.5*this.drone3omegas3*dt;//motor4
  }




  checkkeyborad(){


  const RATIO = 1.0003;
  /////////////////////////////////////////////////////////////
  // for hovering
   if (keyboard.pressed('up')) {
   
    $('#thrustUp').css ("background-color",  'red');
    this.drone3omegaGains *= RATIO;
  }
  if (keyboard.up('up')) {
    this.drone3yrefs = this.drone3cannon.position.y;
    console.log ('set yref: ' + this.drone3yrefs);
    this.drone3omegaGains = 1;
    $('#thrustUp').css ("background-color",  'white');
  }
  if (keyboard.pressed('down')) {
    $('#thrustDo').css ("background-color",  'yellow');
    this.drone3omegaGains /= RATIO;
  }
  if (keyboard.up('down')) {
    this.drone3yrefs = this.drone3cannon.position.y;
    console.log ('set yref: ' + this.drone3yrefs);
    $('#thrustDo').css ("background-color",  'white');
    this.drone3omegaGains = 1;
  }
  /////////////////////////////////////////////////////////////
  // for rolling
  if (keyboard.pressed('D')) {
    $('#rollRight').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.drone3rollRefs = 0.1;
  }
  if (keyboard.up('D')) {
    $('#rollRight').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.drone3rollRefs = 0;
    this.drone3rollings = false;  
  }
  if (keyboard.pressed('A')) {
    $('#rollLeft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.drone3rollRefs = -0.1;
  }
  if (keyboard.up('A')) {
    $('#rollLeft').css ("background-color",  'white');
    this.drone3rollRefs = 0;
    this.drone3rollings = false;    
  }
  /////////////////////////////////////////////////////////////
  // for pitching
  if (keyboard.pressed('W')) {
    $('#pitchFore').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    this.drone3pitchRefs = 0.1;
    this.drone3pitchings=true;
  }
  if (keyboard.up('W')) {
    $('#pitchFore').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    this.drone3pitchRefs = 0;
    this.drone3pitchings = false; 
  }
  if (keyboard.pressed('S')) {
    $('#pitchAft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        this.drone3pitchRefs = -0.1;
        this.drone3pitchings=true;
  }
  if (keyboard.up('S')) {
    $('#pitchAft').css ("background-color",  'white');
    this.drone3pitchRefs= 0;
    this.drone3pitchings = false;   
  }
  /////////////////////////////////////////////////////////////
  // for yawing
  if (keyboard.pressed('left')) {

        this.drone3rYaws = this.drone3omegaHovers*0.1;
        this.drone3turnings = true;
  }
  if (keyboard.up('left')) {
        this.drone3rYaws = 0;
        this.drone3turnings = false;
    
      // set up stopping reference
      this.drone3yawRefs = getBodyYaw2(this.drone3cannon);
    if((this.drone3yawRefs/Math.PI*180).toFixed(2)==360)this.drone3yawRefs=0;

      //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
  }
  if (keyboard.pressed('right')) {
        this.drone3rYaws = -this.drone3omegaHovers*0.1;
        this.drone3turnings = true;
  }
  if (keyboard.up('right')) {
    this.drone3rYaws = 0;
    this.drone3turnings = false;
    // set up stopping reference
    this.drone3yawRefs = getBodyYaw2(this.drone3cannon);
    if((this.drone3yawRefs/Math.PI*180).toFixed(2)==360)this.drone3yawRefs=0;
         //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
      console.log ('set thetaRef: ' + (this.drone3yawRefs/Math.PI*180).toFixed(2));
      //console.log(turning+omegaHover);
  }
  if (keyboard.pressed('space')) {
    this.drone3yawRefs = getBodyYaw2(this.drone3cannon);
    this.drone3rYaws=0;
    this.drone3turnings=false;
    this.drone3pitchRefs = 0;
    this.drone3pitchings = false; 
    this.drone3rollRefs = 0;
    this.drone3rolling = false;  
    $('#stop').css ("background-color",  'yellow');
  }
  if (keyboard.up('space')) {
    $('#stop').css ("background-color",  'white');
  }



     }



}

  $('#showStart1').click(function() {
       droneshow1=!droneshow1;
    });
    $('#showStart2').click(function() {
       droneshow2=!droneshow2;
    });
        $('#adddrone').click(function() {
       droneadd=!droneadd;
    });
    $('#showline1').click(function() {
       showline1=!showline1;
    });
    $('#showline2').click(function() {
       showline2=!showline2;
    });
        $('#showline3').click(function() {
       showline3=!showline3;
    });
var world, body,body2,body3; 
var camera,upcamera,scene, renderer, clock, keyboard, airplane,circle,light2;
var omega, omega0, omega1, omega2, omega3,omega0Temp,omega1Temp,omega2Temp,omega3Temp;
const SIZE = 1;
var omegaGain = 1.0;
var omegaHover;
const PROP_KK = 0.1;
var controller=false;
// flight maneuver
// hovering
var yref = 5;   
var turning = true;
var rolling = true;
var pitching=true;
var rYaw = 0;
var rRoll = 0;
var rPitch = 0;
var yawAngle = 0, yawRef = 0;
var rollAngle = 0, rollRef = 0;
var pitchAngle = 0, pitchRef = 0;
var gyro;
var droneshow1=false,droneshow2=false,droneadd=false,firstline1=false,firstline2=false,firstline3=false,showline1=false,showline2=false,showline3=false;
var select=2;
var targetPos,targetPos2,targetPos3;
var clock = new THREE.Clock(),curve3,curveObject1,curveObject3,curve2,curveObject2,curve4,curve5,curveObject4,curveObject5;
var circle1,circle2,circle3,circleObject1,circleObject2,circleObject3;
var sceneHUD, cameraHUD;
var pointer = [], sprite = [];
var pickables;
var box,box2,box3,line1,line3,line4,fatline1,fatline2;
var y1,v1,speedRef,y2,v2,numberRef1,y3,v3,numberRef2,y4,v4,numberRef3,y5,v5,numberRef4;////hud 的各种pd控制系统参数
var cylindery1,cylindery2,cylindery3,cylindery4; 
var showdetail=false;
var mouse = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var SpeedCylinder,SpeedChange=2;
var circleAngel=0,SloopAngle=0,curveGeom1,showplane1,showplane2,parking;
var angle1 = angle2 = 0;
var curveCcw,curveCw,Sloopcurve,point1, curveObjectt, geometryCurve, materialCurve;
var Raidus=3,R=2,r,rr;
var drones=[],drone3s;
var angley1,anglev1,angleRef1,angley2,anglev2,angleRef2,angley3,anglev3,angleRef3;
/////////////////


init();
animate();
   /* $('#yawref').change ( function() {
        yawref = $(this).val();
        $('#yawtext').val (yawref);
    });
*/

function init() {
    keyboard = new KeyboardState();
    initThree();
    initCannon();


    var ww1 = $('#Cameras').innerWidth();
    var hh1 = $('#Cameras').innerHeight();
    var cc1 = document.getElementById('mycanvas');
    rendererCams = new THREE.WebGLRenderer({
    canvas: cc1
    });
    rendererCams.setSize(ww1, hh1);
    
    light2.target=airplane;

    drones[0]=new drone(-2,6,-2);
    //pidR2 = new PIDControllerR2();
  /////////////////////////////
  // omegaHover: stable hover speed
  omegaHover = Math.sqrt ( body.mass * world.gravity.length()/4/PROP_KK );
  cameraHUD = new THREE.OrthographicCamera(-15, 15, 10, -10, -10, 1000);
  cameraHUD.position.z = 100; 
  gyro = new THREE.Gyroscope();
  scene.add (gyro,upcamera)
  gyro.add (camera);
  airplane.add (gyro)
  pickables=[airplane.children[9],airplane.children[11],airplane.children[12],airplane.children[10]];
  targetPos= new THREE.Vector3(5,5,-5);
  var r=1;
    ///////////////////////////

   ////////////////////////////
 
  box=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05, 0.1, 20), new THREE.MeshPhongMaterial());
  box2=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05, 0.1, 20), new THREE.MeshPhongMaterial());
  scene.add(box,box2);
  box.visible=false;
  box2.visible=false;
  speedRef=[];
  sy=[];
  sy[1]=v1=y2=v2=numberRef1=speedRef[1]=sy[2]=sv2=speedRef[2]=sy[3]=sv3=speedRef[3]=sy[4]=sv4=speedRef[4]=y3=v3=numberRef2=y4=v4=numberRef3=y5=v5=numberRef4=0;
  cylindery1=cylinderv1=cylinderRef1=cylindery2=cylinderv2=cylinderRef2=cylindery3=cylinderv3=cylinderRef3=cylindery4=cylinderv=cylinderRef4=0;
  angley1=anglev1=angleRef1=angley2=anglev2=angleRef2=angley3=anglev3=angleRef3=0;
  document.addEventListener('mousedown', onDocumentMouseDown, false)
//////////////////////////fatline
var createFatLineGeometry = function (opt) {
 
    opt = opt || {};
    opt.forPoint = opt.forPoint || function (i, per) {
        return {
            x: i * 5,
            y: 0,
            z: 0
        }
    };
    opt.ptCount = opt.ptCount === undefined ? 20 : opt.ptCount;
    opt.colorSolid = opt.colorSolid === undefined ? false : opt.colorSolid;
    opt.color = opt.color === undefined ? new THREE.Color(0xffffff) : opt.color;
 
    // Position and Color Data
    var positions = [],
    colors = [],
    i = 0,
    point,
    geo;
 
    // for each point
    while (i < opt.ptCount) {
 
        // push point
        point = opt.forPoint(i, i / opt.ptCount);
        positions.push(point.x, point.y, point.z);
 
        // push color
        if (!opt.colorSolid) {
            opt.color.setHSL(i / opt.ptCount, 1.0, 0.5);
        }
        colors.push(opt.color.r, opt.color.g, opt.color.b);
 
        i += 1;
    }
 
    // return geo
    geo = new THREE.LineGeometry();
    geo.setPositions(positions);
    geo.setColors(colors);
    return geo;
 
};

fatline1=new THREE.Object3D();
 line1 = createFatLine({
            width: 1,
            geo: createFatLineGeometry({
                ptCount: 80,
                colorSolid: true,
                color: new THREE.Color(0x00ff00),
                forPoint: function (i, per) {
                    return {
                        x: Math.cos(Math.PI*3*(per))*2 ,
                        y: 0,
                        z: Math.sin(Math.PI*3*(per))*2
                    }
                }
            })
        });
 fatline1.add(line1);
 fatline1.position.y=5;
  fatline1.position.x+=3;
  //////////////////////
 fatline2=new THREE.Object3D();
 line2 = createFatLine({
            width: 1,
            geo: createFatLineGeometry({
                ptCount: 80,
                colorSolid: true,
                color: new THREE.Color(0xff0000),
                forPoint: function (i, per) {
                    return {
                        x: Math.cos(Math.PI*3*(per))*2 ,
                        y: 0,
                        z: Math.sin(Math.PI*3*(per))*2
                    }
                }
            })
        });
 fatline2.add(line2);
 fatline2.position.y=5;
  fatline2.position.x+=-3;

  ///////////////////
  R=2, r=6,rr=3;
  curve3 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(0, 5 ,0-3),
        new THREE.Vector3(0, R*0.5*Math.sqrt(2)+5 ,-0.5*R*Math.sqrt(2)+R-3),
        new THREE.Vector3( 0,5+R,R-3),
        new THREE.Vector3( 0,5+R*0.5*Math.sqrt(2),R+0.5*R*Math.sqrt(2)-3),
        new THREE.Vector3( 0,5,2*R-3),
        new THREE.Vector3( 0,5-R*0.5*Math.sqrt(2),R+0.5*R*Math.sqrt(2)-3),
        new THREE.Vector3( 0,5-R,R-3),
       new THREE.Vector3(0, -R*0.5*Math.sqrt(2)+5 ,-0.5*R*Math.sqrt(2)+R-3),

       /* new THREE.Vector3(-R, 5 ,0),
        new THREE.Vector3(-0.5*R*Math.sqrt(2)+R-R, 5 ,R*0.5*Math.sqrt(2)),
        new THREE.Vector3( 0,  5,R),
        new THREE.Vector3( 0.5*R*Math.sqrt(2)+R-R, 5,R*0.5*Math.sqrt(2)),
        new THREE.Vector3( R,5,0),        
        new THREE.Vector3(  0.5*R*Math.sqrt(2)+R-R, 5 ,-R*0.5*Math.sqrt(2)),       
        new THREE.Vector3( 0, 5,-R),    
        new THREE.Vector3(-0.5*R*Math.sqrt(2)+R-R, 5,-R*0.5*Math.sqrt(2))   */
  ] ,true);


  var points3 = curve3.getPoints( 50 );
  var geometry3 = new THREE.BufferGeometry().setFromPoints( points3 );
  var material3 = new THREE.LineBasicMaterial( { color : 0xffff00 } );
  curveObject3 = new THREE.Line( geometry3, material3 );

    curve1 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(3, 6 ,-3),
        new THREE.Vector3(3, rr*0.5*Math.sqrt(2)+6 ,-0.5*rr*Math.sqrt(2)+rr-3),
        new THREE.Vector3( 3,6+rr,rr-3),
        new THREE.Vector3( 3,6+rr*0.5*Math.sqrt(2),rr+0.5*rr*Math.sqrt(2)-3),
        new THREE.Vector3( 3,6,2*rr-3),
        new THREE.Vector3( 3,6-rr*0.5*Math.sqrt(2),rr+0.5*rr*Math.sqrt(2)-3),
        new THREE.Vector3( 3,6-rr,rr-3),
       new THREE.Vector3(3, -rr*0.5*Math.sqrt(2)+6 ,-0.5*rr*Math.sqrt(2)+rr-3),
  ] ,true);


  var points1 = curve1.getPoints( 50 );
  var geometry1 = new THREE.BufferGeometry().setFromPoints( points1 );
  var material1 = new THREE.LineBasicMaterial( { color : 0xffff00 } );
  curveObject1 = new THREE.Line( geometry1, material1 );

      curve2 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(-3, 6 ,-3),
        new THREE.Vector3(-3, rr*0.5*Math.sqrt(2)+6 ,-0.5*rr*Math.sqrt(2)+rr-3),
        new THREE.Vector3( -3,6+rr,rr-3),
        new THREE.Vector3( -3,6+rr*0.5*Math.sqrt(2),rr+0.5*rr*Math.sqrt(2)-3),
        new THREE.Vector3( -3,6,2*rr-3),
        new THREE.Vector3( -3,6-rr*0.5*Math.sqrt(2),rr+0.5*rr*Math.sqrt(2)-3),
        new THREE.Vector3( -3,6-rr,rr-3),
       new THREE.Vector3(-3, -rr*0.5*Math.sqrt(2)+6 ,-0.5*rr*Math.sqrt(2)+rr-3),
  ] ,true);


  var points2 = curve2.getPoints( 50 );
  var geometry2 = new THREE.BufferGeometry().setFromPoints( points2 );
  var material2 = new THREE.LineBasicMaterial( { color : 0xffff00 } );
  curveObject2 = new THREE.Line( geometry2, material2 );


    curve4 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(-r, 6 ,-r),
        new THREE.Vector3(-r+r*0.5*Math.sqrt(2),6+1 ,-0.5*r*Math.sqrt(2)),
        new THREE.Vector3( 0,6+2,0),
        new THREE.Vector3( r-r*0.5*Math.sqrt(2),6+1,0.5*r*Math.sqrt(2)),
        new THREE.Vector3( r,6,r)
  ] ,false);


  var points4 = curve4.getPoints( 50 );
  var geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
  var material4 = new THREE.LineBasicMaterial( { color : 0xffff00 } );
  curveObject4 = new THREE.Line( geometry4, material4 );
////////////////////////////

/////////////////////////////
    curve5 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(r, 6 ,-r),
        new THREE.Vector3(r-r*0.5*Math.sqrt(2),6-3 ,-0.5*r*Math.sqrt(2)),
        new THREE.Vector3( 0,6-4,0),
        new THREE.Vector3( -r+r*0.5*Math.sqrt(2),6-3,0.5*r*Math.sqrt(2)),
        new THREE.Vector3( -r,6,r)
  ] ,false);


  var points5 = curve5.getPoints( 50 );
  var geometry5 = new THREE.BufferGeometry().setFromPoints( points5 );
  var material5 = new THREE.LineBasicMaterial( { color : 0xffff00 } );
  curveObject5 = new THREE.Line( geometry5, material5 );
  //////////////////////////////////

  var R1=8,R2=6,R3=4;

      circle1 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(-R1, 5 ,0),
        new THREE.Vector3(-0.5*R1*Math.sqrt(2)+R1-R1, 5 ,R1*0.5*Math.sqrt(2)),
        new THREE.Vector3( 0,  5,R1),
        new THREE.Vector3( 0.5*R1*Math.sqrt(2)+R1-R1, 5,R1*0.5*Math.sqrt(2)),
        new THREE.Vector3( R1,5,0),        
        new THREE.Vector3(  0.5*R1*Math.sqrt(2)+R1-R1, 5 ,-R1*0.5*Math.sqrt(2)),       
        new THREE.Vector3( 0, 5,-R1),    
        new THREE.Vector3(-0.5*R1*Math.sqrt(2)+R1-R1, 5,-R1*0.5*Math.sqrt(2)), 

  ] ,true);


  var circlepoints = circle1.getPoints( 50 );
  var circlegeometry = new THREE.BufferGeometry().setFromPoints( circlepoints );
  circleObject1 = new THREE.Line( circlegeometry, material5 );

        circle2 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(-R2, 5 ,0),
        new THREE.Vector3(-0.5*R2*Math.sqrt(2)+R2-R2, 5 ,R2*0.5*Math.sqrt(2)),
        new THREE.Vector3( 0,  5,R2),
        new THREE.Vector3( 0.5*R2*Math.sqrt(2)+R2-R2, 5,R2*0.5*Math.sqrt(2)),
        new THREE.Vector3( R2,5,0),        
        new THREE.Vector3(  0.5*R2*Math.sqrt(2)+R2-R2, 5 ,-R2*0.5*Math.sqrt(2)),       
        new THREE.Vector3( 0, 5,-R2),    
        new THREE.Vector3(-0.5*R2*Math.sqrt(2)+R2-R2, 5,-R2*0.5*Math.sqrt(2)), 

  ] ,true);


  var circlepoints2 = circle2.getPoints( 50 );
  var circlegeometry2 = new THREE.BufferGeometry().setFromPoints( circlepoints2 );
  circleObject2 = new THREE.Line( circlegeometry2, material5 );



          circle3 = new THREE.CatmullRomCurve3( [
        new THREE.Vector3(-R3, 5 ,0),
        new THREE.Vector3(-0.5*R3*Math.sqrt(2)+R3-R3, 5 ,R3*0.5*Math.sqrt(2)),
        new THREE.Vector3( 0,  5,R3),
        new THREE.Vector3( 0.5*R3*Math.sqrt(2)+R3-R3, 5,R3*0.5*Math.sqrt(2)),
        new THREE.Vector3( R3,5,0),        
        new THREE.Vector3(  0.5*R3*Math.sqrt(2)+R3-R3, 5 ,-R3*0.5*Math.sqrt(2)),       
        new THREE.Vector3( 0, 5,-R3),    
        new THREE.Vector3(-0.5*R3*Math.sqrt(2)+R3-R3, 5,-R3*0.5*Math.sqrt(2)), 

  ] ,true);


  var circlepoints3 = circle3.getPoints( 50 );
  var circlegeometry3 = new THREE.BufferGeometry().setFromPoints( circlepoints3 );
  circleObject3 = new THREE.Line( circlegeometry3, material5 );
  //////////////////////////////
  //////////////////////////////
 // scene.add(curveObject3,curveObject1,curveObject2);
 // scene.add(circleObject1,circleObject2,circleObject3);
    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    texture = loader.load('https://i.imgur.com/81lKBzW.png');
    parking= new THREE.Mesh( new THREE.CircleGeometry( 1, 32 ), new THREE.MeshPhongMaterial({
    map: texture,
    side: THREE.DoubleSide
    }));
    scene.add(parking);
    parking.rotation.x=-Math.PI/2;
}
function onWindowResize() {
  // renderer resize
  renderer.setSize(window.innerWidth, window.innerHeight);
  whRatio = window.innerWidth / window.innerHeight;
  // perspective camera resize
  camera1.aspect = whRatio;
  camera1.updateProjectionMatrix();
  // orthographic camera resize
  halfH = 20;
  halfW = whRatio * halfH;
  cameraHUD.left = -halfW;
  cameraHUD.right = halfW;
  cameraHUD.top = halfH;
  cameraHUD.bottom = -halfH;
  cameraHUD.updateProjectionMatrix();
  dashBoard[0].position.set(-halfW / 2.5, -(halfH - halfW / 10), 0)
  dashBoard[1].position.set(-halfW / 8, -(halfH - halfW / 10), 0)
  dashBoard[2].position.set(halfW / 8, -(halfH - halfW / 10), 0)
  dashBoard[3].position.set(halfW / 2.5, -(halfH - halfW / 10), 0)
}
function onDocumentMouseDown(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables, false);
  if(intersects.length>0){
     showdetail=!showdetail;
     console.log("2");
}
}
var maxVelocity=0.4;
var orientationcurve=new THREE.Vector3();
var orientationcurve2=new THREE.Vector3();
var orientationcurve3=new THREE.Vector3();

var Time1=0,Time2=0,Time3=0,dtt,Time11=0.1;

var cylinder=[],ready=false;


function animate() {
  
  rendererCams.render(scene, upcamera);
  upcamera.position.copy(airplane.localToWorld(new THREE.Vector3(0,1,-1.5)));
  upcamera.lookAt(airplane.position);
  
  var f1 = speedServo(sy[1],v1,speedRef[1]); 
  dtt = 0.005;
  v1 += f1*dtt;
  sy[1] += v1*dtt;
  var f6= speedServo(sy[2],sv2,speedRef[2]); 
  sv2 += f6*dtt;
  sy[2] += sv2*dtt;
    var f7 = speedServo(sy[3],sv3,speedRef[3]); 
  sv3 += f7*dtt;
  sy[3] += sv3*dtt;
    var f8 = speedServo(sy[4],sv4,speedRef[4]); 
  sv4 += f8*dtt;
  sy[4]+= sv4*dtt;

  var f2 = numberServo(y2,v2,numberRef1); 
  v2 += f2*dtt;
  y2 += v2*dtt;
  cylindery1 =y2*0.05;
  var f3 = numberServo(y3,v3,numberRef2); 
  v3 += f3*dtt;
  y3 += v3*dtt;
  cylindery2 =y3*0.05;
  var f4 = numberServo(y4,v4,numberRef3); 
  v4 += f4*dtt;
  y4 += v4*dtt;
  cylindery3 =y4*0.05;
  var f5 = numberServo(y5,v5,numberRef4); 
  v5 += f5*dtt;
  y5 += v5*dtt;
  cylindery4 =y5*0.05;
   var f9 = speedServo(angley1,anglev1,angleRef1); 
  anglev1 += f9*dtt;
  angley1+= anglev1*dtt;


   var f10 = speedServo(angley2,anglev2,angleRef2); 
  anglev2 += f10*dtt;
  angley2+= anglev2*dtt;

   var f11 = speedServo(angley3,anglev3,angleRef3); 
  anglev3 += f11*dtt;
  angley3+= anglev3*dtt;


  let dt = clock.getDelta();

  //orientation=targetPos.clone().sub(body.position);
 
   //  console.log(orientaionLocal);

 /* if(autocontroller1){ 
  autocontroller2=false;
  autocontroller3=false;
     rYaw = 0;
    turning = false;  
  targetPos=new THREE.Vector3(8,5,-10);
     rollRef = 0;
   rolling = false; 
   if(orientation.x-maxVelocity>0){
      rollRef = -0.05;
     }
  if(orientation.x+maxVelocity<0){
    rollRef = 0.05;
  }
    pitchRef =0;
      pitching=false; 
   if(orientation.z-maxVelocity>0){
      pitchRef = 0.05;
        pitching=true;
     }
  if(orientation.z+maxVelocity<0){
      pitchRef = -0.05;
        pitching=true;
  }
}
if(autocontroller2){
  autocontroller1=false;
  autocontroller3=false;
  targetPos=new THREE.Vector3(5,5,-5);
  rYaw = 0;
  turning = false;  
  var localY, localZ;
  localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
  localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
  var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
  var x =new THREE.Vector3(orientation.clone().normalize().x,orientation.clone().normalize().y,orientation.clone().normalize().z);
  var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
  var zW = new THREE.Vector3 (0,0,1);
  var v = zW.projectOnPlane (yL);
  var yawAngle =  rotateAlongAxisTo (x, yL, zL);
     if(yawAngle-0.2>0) {
      rYaw = -omegaHover*0.1;
        turning = true;
     }
  if(yawAngle+0.2<0){
      rYaw = omegaHover*0.1;
        turning = true;
   }
     targetPosx=new THREE.Vector3(0,targetPos.y,targetPos.z);
     orientationx=targetPosx.clone().sub(body.position).normalize();
     var z=zW.projectOnPlane(orientationx);
     pitchRef =0;
     pitching=false;  
   if(z.z>0){
     pitchRef = 0.05;
       pitching=true;
     }
  if(z.z<0){
     pitchRef = -0.05;
       pitching=true;
  }
}*/
////////////圆平面的变化
if(droneshow1){
  if(!firstline1){
      body.position.set(3.5-Raidus,5,0);
    //  if(droneadd)drones[0].cannon.position.set(curveCw.getPointAt(Time1 % 1))
      firstline1=true;
    }
if(showline1){
  showplane1.visible=true;
}
if(!showline1)
   showplane1.visible=false;
  scene.add(fatline1)
  angleRef1+=0.001;
  CreateCurve(angley1);
  fatline1.rotation.z=angley1;
  box.position.copy(curveCcw.getPointAt(Time1 % 1));
  box.position.y+=0.05
   showplane1.rotation.z=angley1;
    //console.log(Time1);
  targetPos=curveCcw.getPointAt(Time1 % 1);
  orientationcurve=targetPos.clone().sub(body.position).normalize();
 // orientationcurve=curveCcw.getTangent(Time1 % 1);
  yref=targetPos.y;
  rYaw = 0;
  turning = false;  
  var localY, localZ;
  localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
  localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
  var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
  var x =new THREE.Vector3(orientationcurve.clone().normalize().x,orientationcurve.clone().normalize().y,orientationcurve.clone().normalize().z);
  var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
  var zW = new THREE.Vector3 (0,0,1);
  var v = zW.projectOnPlane (yL);
  var yawAngle =  rotateAlongAxisTo (x, yL, zL);
  if(yawAngle-0.2>0) {
  rYaw = -omegaHover*0.1;
  turning = true;
  }
  if(yawAngle+0.2<0){
  rYaw = omegaHover*0.1;
  turning = true;
  }
  targetPosx=new THREE.Vector3(0,targetPos.y,targetPos.z);
  orientationx=targetPosx.clone().sub(body.position).normalize();
  var z=zW.projectOnPlane(orientationx);
  pitchRef =0;
  pitching=false;  
  if(z.z>0){
  pitchRef = 0.03;
  pitching=true;
  }
  if(z.z<0){
  pitchRef = -0.03;
  pitching=true;
  }
  if(targetPos.x-body.position.x<=0.5&&targetPos.x-body.position.x>=-0.5){ 
      if(targetPos.z-body.position.z<=0.5&&targetPos.z-body.position.z>=-0.5){
      Time1 += 0.003;
      turning=false;
      pitchRef = 0;
      pitching = false; 
      rollRef = 0;
      rolling = false;
      ready=true;
    }
 }  
/////////
if(droneadd){
  if(showline1){
  showplane2.visible=true;
}
if(!showline1)
   showplane2.visible=false;
  CreateCwCurve(-angley1);
  fatline2.rotation.z=-angley1;
  scene.add(fatline2)
  box2.position.copy(curveCw.getPointAt(Time1 % 1));
  box2.position.y+=0.05
  showplane2.rotation.z=-angley1;
  targetPos2=curveCw.getPointAt(Time1 % 1);
  orientationcurve2=targetPos2.clone().sub(drones[0].cannon.position).normalize();
  //orientationcurve=curve3.getTangent(Time1 % 1);
  drones[0].yrefs=targetPos2.y;
  drones[0].rYaws = 0;
  drones[0].turnings = false;  
  var localY2 = drones[0].cannon.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
  var localZ2 = drones[0].cannon.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
  var yL2 = new THREE.Vector3 (localY2.x, localY2.y, localY2.z);
  var x2 =new THREE.Vector3(orientationcurve2.clone().normalize().x,orientationcurve2.clone().normalize().y,orientationcurve2.clone().normalize().z);
  var zL2 = new THREE.Vector3 (localZ2.x, localZ2.y, localZ2.z);
  var zW2 = new THREE.Vector3 (0,0,1);
  var yawAngle =  rotateAlongAxisTo (x2, yL2, zL2);
  if(yawAngle-0.2>0) {
  drones[0].rYaws = -drones[0].omegaHovers*0.1;
  drones[0].turnings = true;
  }
  if(yawAngle+0.2<0){
  drones[0].rYaws = drones[0].omegaHovers*0.1;
  drones[0].turnings = true;
  }
  targetPosx=new THREE.Vector3(0,targetPos2.y,targetPos2.z);
  orientationx=targetPosx.clone().sub(drones[0].cannon.position).normalize();
  var z2=zW2.projectOnPlane(orientationx);
  drones[0].pitchRefs =0;
 drones[0].pitchings=false;  
  if(z2.z>0){
  drones[0].pitchRefs = 0.04;
  drones[0].pitchings=true;
  }
  if(z2.z<0){
  drones[0].pitchRefs = -0.04;
  drones[0].pitchings=true;
  }
  if(targetPos2.x-drones[0].cannon.position.x<=0.5&&targetPos2.x-drones[0].cannon.position.x>=-0.5){ 
      if(targetPos2.z-drones[0].cannon.position.z<=0.5&&targetPos2.z-drones[0].cannon.position.z>=-0.5){
      //Time2 += 0.00195;
      drones[0].turnings=false;
      drones[0].pitchRefs = 0;
      drones[0].pitchings = false; 
      drones[0].rollRefs = 0;
      drones[0].rollings = false;
     // ready=true;
    }
 }
//////////

}


}

if(droneshow2){
  if(showline2){
  scene.add(curveObject3,curveObject4,curveObject5);
  box.visible=true;
  box2.visible=true;
  box3.visible=true;
}
if(!showline2){
   scene.remove(curveObject3,curveObject4,curveObject5);
   box.visible=false;
  box2.visible=false;
  box3.visible=false;
}
  if(!firstline2){
    firstline2=true;
    body.position.copy(curve3.getPointAt(0));
    drones[0].cannon.position.copy(curve4.getPointAt(0));
   drone3s.drone3cannon.position.copy(curve5.getPointAt(0));
  }
  box.position.copy(curve3.getPointAt(Time1 % 1));
  box.position.y+=0.05
    //console.log(Time1);
  targetPos=curve3.getPointAt(Time1 % 1);
  orientationcurve=targetPos.clone().sub(body.position).normalize();
  //orientationcurve=curve3.getTangent(Time1 % 1);
  yref=targetPos.y;
  rYaw = 0;
  turning = false;  
  var localY, localZ;
  localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
  localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
  var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
  var x =new THREE.Vector3(orientationcurve.clone().normalize().x,orientationcurve.clone().normalize().y,orientationcurve.clone().normalize().z);
  var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
  var zW = new THREE.Vector3 (0,0,1);
  var v = zW.projectOnPlane (yL);
  var yawAngle =  rotateAlongAxisTo (x, yL, zL);
  if(yawAngle-0.2>0) {
  rYaw = -omegaHover*0.1;
  turning = true;
  }
  if(yawAngle+0.2<0){
  rYaw = omegaHover*0.1;
  turning = true;
  }
  targetPosx=new THREE.Vector3(0,targetPos.y,targetPos.z);
  orientationx=targetPosx.clone().sub(body.position).normalize();
  var z=zW.projectOnPlane(orientationx);
  pitchRef =0;
  pitching=false;  
  if(z.z>0){
  pitchRef = 0.02;
  pitching=true;
  }
  if(z.z<0){
  pitchRef = -0.02;
  pitching=true;
  }
  if(targetPos.x-body.position.x<=0.5&&targetPos.x-body.position.x>=-0.5){ 
      if(targetPos.z-body.position.z<=0.5&&targetPos.z-body.position.z>=-0.5){
      Time1 += 0.00095;
      turning=false;
      pitchRef = 0;
      pitching = false; 
      rollRef = 0;
      rolling = false;
      ready=true;
    }
 }
/////////
  box2.position.copy(curve4.getPointAt(Time2 % 1));
  box2.position.y+=0.05
  targetPos2=curve4.getPointAt(Time2 % 1);
  orientationcurve2=targetPos2.clone().sub(drones[0].cannon.position).normalize();
  //orientationcurve=curve3.getTangent(Time1 % 1);
  drones[0].yrefs=targetPos2.y;
  drones[0].rYaws = 0;
  drones[0].turnings = false;  
  var localY2 = drones[0].cannon.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
  var localZ2 = drones[0].cannon.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
  var yL2 = new THREE.Vector3 (localY2.x, localY2.y, localY2.z);
  var x2 =new THREE.Vector3(orientationcurve2.clone().normalize().x,orientationcurve2.clone().normalize().y,orientationcurve2.clone().normalize().z);
  var zL2 = new THREE.Vector3 (localZ2.x, localZ2.y, localZ2.z);
  var zW2 = new THREE.Vector3 (0,0,1);
  var yawAngle =  rotateAlongAxisTo (x2, yL2, zL2);
  if(yawAngle-0.2>0) {
  drones[0].rYaws = -drones[0].omegaHovers*0.1;
  drones[0].turnings = true;
  }
  if(yawAngle+0.2<0){
  drones[0].rYaws = drones[0].omegaHovers*0.1;
  drones[0].turnings = true;
  }
  targetPosx=new THREE.Vector3(0,targetPos2.y,targetPos2.z);
  orientationx=targetPosx.clone().sub(drones[0].cannon.position).normalize();
  var z2=zW2.projectOnPlane(orientationx);
  drones[0].pitchRefs =0;
 drones[0].pitchings=false;  
  if(z2.z>0){
  drones[0].pitchRefs = 0.04;
  drones[0].pitchings=true;
  }
  if(z2.z<0){
  drones[0].pitchRefs = -0.04;
  drones[0].pitchings=true;
  }
  if(targetPos2.x-drones[0].cannon.position.x<=0.5&&targetPos2.x-drones[0].cannon.position.x>=-0.5&&Time2<=0.98805){ 
      if(targetPos2.z-drones[0].cannon.position.z<=0.5&&targetPos2.z-drones[0].cannon.position.z>=-0.5){
      Time2 += 0.00195;

      drones[0].turnings=false;
      drones[0].pitchRefs = 0;
      drones[0].pitchings = false; 
      drones[0].rollRefs = 0;
      drones[0].rollings = false;
     // ready=true;
    }
 }
//////////
  



}


  // not in thrust+/- mode, activate hoverServo
  if (omegaGain === 1.0) 
  omega = hoverServo(body, dt);
  else
  omega = omegaGain*omegaHover;  // this looks much better
  omega = Math.clamp (omega, 0, 50);
 // console.log("ryaw: "+rYaw+" "+turning);
  
  if (! turning) {
    //console.log("turningryaw: "+rYaw);
    rYaw = yawServo (body, dt);
    //console.log("servoryaw: "+rYaw);
    rYaw = Math.clamp (rYaw, -omega, omega);
  }  
// always activate rollServo and pitchServo
  rRoll = rollServo (body, dt);
  //rRoll = Math.clamp (rRoll, -omega*0.15, omega*0.15);
  rPitch = pitchServo (body, dt);
  //rPitch = Math.clamp (rPitch, -omega*0.15, omega*0.15);
  
  omega0Temp=omega0;
  omega1Temp=omega1;
  omega2Temp=omega2;
  omega3Temp=omega3;
  omega0 = omega - rYaw - rRoll - rPitch;
  omega1 = omega + rYaw - rRoll + rPitch;
  omega2 = omega - rYaw + rRoll + rPitch;
  omega3 = omega + rYaw + rRoll - rPitch;//0x1742ab
  if(showdetail){
 
  cylinderRef1=omega0*8;
  cylinderRef2=omega1*8;
  cylinderRef3=omega2*8;
  cylinderRef4=omega3*8;
  airplane.children[13].children[0].visible=true;
  airplane.children[14].children[0].visible=true;
  airplane.children[15].children[0].visible=true;
  airplane.children[16].children[0].visible=true;
  airplane.children[25].children[0].visible=true;
  airplane.children[26].children[0].visible=true;
  airplane.children[27].children[0].visible=true;
  airplane.children[28].children[0].visible=true;
 
  airplane.children[25].children[0].scale.y = -3*cylindery1;
  airplane.children[26].children[0].scale.y = 3*cylindery2;
  airplane.children[27].children[0].scale.y = -3*cylindery3;
  airplane.children[28].children[0].scale.y = 3*cylindery4;
/* airplane.children[13].add(new THREE.AxesHelper (0.5));
 airplane.children[14].add(new THREE.AxesHelper (0.5));
airplane.children[15].add(new THREE.AxesHelper (0.5));
airplane.children[16].add(new THREE.AxesHelper (0.5));*/
}
 else {
  airplane.children[13].children[0].visible=false;
  airplane.children[14].children[0].visible=false;
  airplane.children[15].children[0].visible=false;
  airplane.children[16].children[0].visible=false;
  airplane.children[25].children[0].visible=false;
  airplane.children[26].children[0].visible=false;
  airplane.children[27].children[0].visible=false;
  airplane.children[28].children[0].visible=false;
 /*  airplane.children[13].remove(new THREE.AxesHelper (0.5));
 airplane.children[14].remove(new THREE.AxesHelper (0.5));
airplane.children[15].remove(new THREE.AxesHelper (0.5));
airplane.children[16].remove(new THREE.AxesHelper (0.5));*/
 }
  /*omega0 = omega  - rRoll - rPitch;
  omega1 = omega  - rRoll + rPitch;
  omega2 = omega  + rRoll + rPitch;
  omega3 = omega  + rRoll - rPitch;*/
  /*omega0 = omega - rYaw;
  omega1 = omega + rYaw;
  omega2 = omega - rYaw;
  omega3 = omega + rYaw;*/
  body.torque = new CANNON.Vec3(0,0,0);
  body.angularDamping = 0.39
  body.linearDamping = 0.39
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega0*omega0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega1*omega1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega2*omega2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
  body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega3*omega3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 
    
  let KT = 0.1;
  // need to add the last argument
  body.torque.vadd (new CANNON.Vec3(0, -KT*omega0*omega0,0), body.torque);
  body.torque.vadd (new CANNON.Vec3(0,  KT*omega1*omega1,0), body.torque);
  body.torque.vadd (new CANNON.Vec3(0, -KT*omega2*omega2,0), body.torque);
  body.torque.vadd (new CANNON.Vec3(0,  KT*omega3*omega3,0), body.torque);
  //bug ... for pitching, weird number from KT not zero
  //console.log (body.torque)         
  //console.log("omega0:"+omega0.toFixed(2)+" omega1:"+omega1.toFixed(2)+" omega2:"+omega2.toFixed(2)+" omega3:"+omega3.toFixed(2));
  //requestAnimationFrame( animate );
  //renderer.render( scene, camera );

    render();
    if(droneadd)
    drones[0].Movement(dt);
    handleKeys();

    keyboard.update();
    updatePhysics();
    if(droneadd)
    drones[0].update();
  // render propeller in airplane
// console.log(airplane.children[25].children[0].mesh.parameters)
  airplane.children[25].rotation.z += 2.5*omega0*dt;//motor1
  airplane.children[26].rotation.z -= -2.5*omega1*dt;//motor2
  airplane.children[27].rotation.z += 2.5*omega2*dt;//motor3
  airplane.children[28].rotation.z -= -2.5*omega3*dt;//motor4

}
function render(){
  renderer.clear(true);
  requestAnimationFrame(animate);
  renderer.render(scene, camera);

}
function handleKeys () {
  keyboard.update();
  if(droneadd)
  drones[0].checkkeyborad();
  const RATIO = 1.0003;
  /////////////////////////////////////////////////////////////
  // for hovering
  if (keyboard.pressed('up')) {
    controller=true;
    $('#thrustUp').css ("background-color",  'red');
    omegaGain *= RATIO;
  }
  if (keyboard.up('up')) {
    yref = body.position.y;
    console.log ('set yref: ' + yref);
    omegaGain = 1;
    $('#thrustUp').css ("background-color",  'white');
  }
  if (keyboard.pressed('down')) {
    $('#thrustDo').css ("background-color",  'yellow');
    omegaGain /= RATIO;
  }
  if (keyboard.up('down')) {
    yref = body.position.y;
    console.log ('set yref: ' + yref);
    $('#thrustDo').css ("background-color",  'white');
    omegaGain = 1;
  }
  /////////////////////////////////////////////////////////////
  // for rolling
  if (keyboard.pressed('D')) {
    $('#rollRight').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    rollRef = 0.1;
  }
  if (keyboard.up('D')) {
    $('#rollRight').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    rollRef = 0;
    rolling = false;  
  }
  if (keyboard.pressed('A')) {
    $('#rollLeft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        rollRef = -0.1;
  }
  if (keyboard.up('A')) {
    $('#rollLeft').css ("background-color",  'white');
    rollRef = 0;
    rolling = false;    
  }
  /////////////////////////////////////////////////////////////
  // for pitching
  if (keyboard.pressed('W')) {
    $('#pitchFore').css ("background-color",  'yellow');
        //rRoll = omegaHover*0.01;
        //rolling = true;
    pitchRef = 0.1;
    pitching=true;
  }
  if (keyboard.up('W')) {
    $('#pitchFore').css ("background-color",  'white');
    //rRoll = 0;//-omegaHover*0.005;
    pitchRef = 0;
    pitching = false; 
  }
  if (keyboard.pressed('S')) {
    $('#pitchAft').css ("background-color",  'yellow');
        //rRoll = - omegaHover*0.01;
        //rolling = true;
        pitchRef = -0.1;
        pitching=true;
  }
  if (keyboard.up('S')) {
    $('#pitchAft').css ("background-color",  'white');
    pitchRef = 0;
    pitching = false;   
  }
  /////////////////////////////////////////////////////////////
  // for yawing
  if (keyboard.pressed('left')) {
    $('#cwTurn').css ("background-color",  'yellow');
        rYaw = omegaHover*0.1;
        turning = true;
  }
  if (keyboard.up('left')) {
    $('#cwTurn').css ("background-color",  'white');
        rYaw = 0;
        turning = false;
    
      // set up stopping reference
      yawRef = getBodyYaw2(body);
    if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
      console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
      //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
  }
  if (keyboard.pressed('right')) {
    $('#ccwTurn').css ("background-color",  'yellow');
        rYaw = -omegaHover*0.1;
        turning = true;
  }
  if (keyboard.up('right')) {
    $('#ccwTurn').css ("background-color",  'white');
    rYaw = 0;
    turning = false;
    // set up stopping reference
    yawRef = getBodyYaw2(body);
    if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
         //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
      console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
      console.log(turning+omegaHover);
  }
  if (keyboard.pressed('space')) {
    yawRef = getBodyYaw2(body);
    rYaw=0;
    turning=false;
    pitchRef = 0;
    pitching = false; 
    rollRef = 0;
    rolling = false;  
    $('#stop').css ("background-color",  'yellow');
  }
  if (keyboard.up('space')) {
    $('#stop').css ("background-color",  'white');
  }
    $('#gain').val (omegaGain);
    $('#yreftext').val (yref.toFixed(2));

  


}
function updatePhysics() {
  var timeStep=1/50;
  world.step(timeStep);
  // Copy coordinates from Cannon.js to Three.js
  airplane.position.copy(body.position);
  airplane.quaternion.copy(body.quaternion); 
  yawAngle = getBodyYaw2(body);
 if((yawAngle/Math.PI*180).toFixed(2)==360)yawAngle=0;
  rollAngle = getBodyRoll2(body);
  pitchAngle = getBodyPitch2(body);
  
 /* $('#text').html (`${omegaGain.toFixed(3)}:[ ${body.position.x.toFixed(3)}, ${body.position.y.toFixed(2)}, 
    ${body.position.z.toFixed(3)} ] <br>      
  [${yawRef.toFixed(3)}] : [Y: ${yawAngle.toFixed(3)} ] [R: ${rollAngle.toFixed(3)} ] [P: ${pitchAngle.toFixed(3)} ]  
  <br>
     [omega0:${omega0.toFixed(3)}] : [omega1: ${omega1.toFixed(3)} ] [omega2: ${omega2.toFixed(3)} ] [omega3: ${omega3.toFixed(3)} ]         `);  */
}
</script>
</body>
</html>